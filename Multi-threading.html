<!DOCTYPE html>
<html lang="vi" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lập trình Đa luồng (Multi-threading)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Be Vietnam Pro', sans-serif;
            background-color: #f8f9fa; /* Light gray background */
        }
        .code-block {
            background-color: #282c34;
            color: #abb2bf;
            border-radius: 8px;
            padding: 16px;
            font-family: 'Courier New', Courier, monospace;
            overflow-x: auto;
            font-size: 14px;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 400px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 350px;
            }
        }
        /* Deadlock simulation styles */
        #deadlock-circle {
            position: relative;
            width: 300px;
            height: 300px;
            border: 2px dashed #9ca3af;
            border-radius: 50%;
            margin: 2rem auto;
        }
        .philosopher, .fork {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8rem;
            transition: all 0.5s ease-in-out;
        }
        .philosopher {
            background-color: #dbeafe;
            border: 2px solid #93c5fd;
        }
        .fork {
            width: 40px;
            height: 40px;
            background-color: #fef9c3;
            border: 2px solid #fde047;
            font-size: 1.2rem;
        }
		.code-block {
            position: relative; /* Bắt buộc phải có để định vị nút con */
        }
        .copy-button {
            position: absolute;
            top: 0.5rem; /* 8px */
            right: 0.5rem; /* 8px */
            background-color: #4a5568; /* Màu nền xám đậm */
            color: #e2e8f0; /* Màu icon xám nhạt */
            border: none;
            border-radius: 0.375rem; /* bo góc 6px */
            padding: 0.5rem; /* 8px */
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .copy-button:hover {
            background-color: #2d3748; /* Màu nền đậm hơn khi hover */
        }
		.code-block {
            position: relative; /* Giữ nguyên, rất quan trọng */
        }
        .code-toolbar {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            display: flex;
            gap: 0.5rem; /* Khoảng cách giữa các nút */
            z-index: 10;
        }
        .toolbar-button {
            background-color: #4a5568;
            color: #e2e8f0;
            border: none;
            border-radius: 0.375rem;
            padding: 0.5rem;
            cursor: pointer;
            display: flex; /* Để icon và text nằm cạnh nhau */
            align-items: center; /* Căn giữa theo chiều dọc */
            gap: 0.35rem; /* Khoảng cách giữa icon và text */
            font-size: 0.75rem; /* 12px */
            line-height: 1; 
            transition: background-color 0.2s;
            font-family: 'Be Vietnam Pro', sans-serif; /* Đảm bảo font chữ nhất quán */
        }
        .toolbar-button:hover {
            background-color: #2d3748;
        }
    </style>
</head>

<body class="text-gray-800">
    <header class="bg-white/80 backdrop-blur-lg shadow-md sticky top-0 z-50">
        <nav class="container mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <div class="flex-shrink-0">
                    <h1 class="text-xl font-bold text-cyan-700">Lập trình Đa luồng</h1>
                </div>
                <div class="hidden md:block">
                    <div class="ml-10 flex items-baseline space-x-4">
                        <a href="#part1" class="text-gray-600 hover:bg-cyan-600 hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-colors">Mở đầu</a>
                        <a href="#part2" class="text-gray-600 hover:bg-cyan-600 hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-colors">Tiền trình và Luồng</a>
                        <a href="#part3" class="text-gray-600 hover:bg-cyan-600 hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-colors">Lập trình Đa luồng</a>
                        <a href="#part4" class="text-gray-600 hover:bg-cyan-600 hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-colors">Vấn đề thường gặp</a>
                        <a href="#part5" class="text-gray-600 hover:bg-cyan-600 hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-colors">Đồng bộ hóa</a>
                        <a href="#part6" class="text-gray-600 hover:bg-cyan-600 hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-colors">Thực hành</a>
                    </div>
                </div>
            </div>
        </nav>
    </header>

    <main class="container mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <section id="intro" class="text-center py-12">
            <h2 class="text-4xl font-extrabold text-gray-900 sm:text-5xl md:text-6xl"><span class="text-cyan-600">Lập trình Đa luồng (Multi-threading)</span></h2>
            <p class="mt-4 max-w-2xl mx-auto text-xl text-gray-500 whitespace-nowrap">Lý thuyết, thách thức và ứng dụng thực tiễn trong thời kỳ CPU Đa lõi</p>
			<p class="mt-4 text-xl font-bold text-gray-500 text-center whitespace-nowrap">Nguyễn Văn Tuấn, Nguyễn Vũ Cường, Đặng Quang Dư, Trần Hữu Mạnh, Đỗ Văn Mạnh, Dương Huy Hoàng - KTVT37.</p>
        </section>
        
        <section id="part1" class="bg-white rounded-lg shadow-xl p-6 md:p-8 my-12">
            <h3 class="text-3xl font-bold text-center mb-8">1. Mở đầu</h3>
            <div>
                <div>
                    <h4 class="font-bold text-xl mb-3 text-cyan-700">1.1. Thời kỳ của CPU đa lõi</h4>
					<div class="chart-container h-64 md:h-80 md:float-right md:ml-6 mb-4"> 
						<canvas id="mooreLawChart"></canvas>
					</div>
					<div id="content-overall" class="mb-4 text-gray-700 text-justify">
						<p class="mb-4">Trong những thập kỷ đầu của ngành công nghiệp máy tính, hiệu năng của bộ vi xử lý (CPU) tăng trưởng theo một quy luật gần như tuyến tính, được mô tả bởi <strong>Định luật Moore</strong>. Sự tăng trưởng này chủ yếu đến từ việc tăng tốc độ xung nhịp (clock speed) và thu nhỏ kích thước bóng bán dẫn. Tuy nhiên, vào đầu những năm 2000, phương pháp này đã vấp phải những giới hạn vật lý không thể vượt qua, chủ yếu là vấn đề tản nhiệt và tiêu thụ năng lượng. Việc tiếp tục tăng tốc độ xung nhịp sẽ tạo ra một lượng nhiệt khổng lồ, đe dọa phá hủy chính con chip đó.</p>
						<p class="mb-4">Để tiếp tục con đường nâng cao hiệu năng tính toán, ngành công nghiệp phần cứng đã thực hiện một bước chuyển đổi chiến lược: thay vì cố gắng làm cho một bộ não duy nhất chạy nhanh hơn, họ bắt đầu tích hợp nhiều bộ não (lõi - core) vào trong cùng một con chip. Đây chính là sự ra đời của <strong>CPU đa lõi</strong>, một kiến trúc đã trở thành tiêu chuẩn trên mọi thiết bị, từ điện thoại thông minh đến các siêu máy tính. Một CPU hiện đại có thể dễ dàng sở hữu 4, 8, 16 hoặc thậm chí nhiều lõi hơn.</p>
						<p>Sự thay đổi về phần cứng này đã tạo ra một thách thức và cũng là một cơ hội lớn cho các nhà phát triển phần mềm. Một chương trình được viết theo kiểu truyền thống, hay còn gọi là <strong>chương trình đơn luồng (single-threaded)</strong>, chỉ có thể thực thi trên một lõi CPU tại một thời điểm. Điều này có nghĩa là, dù máy tính của bạn có 8 hay 16 lõi, ứng dụng đó cũng chỉ có thể sử dụng một lõi duy nhất, để lại phần lớn năng lực tính toán của hệ thống bị lãng phí. Để khai thác triệt để sức mạnh của phần cứng hiện đại, các lập trình viên cần phải áp dụng một mô hình lập trình mới: <strong>Lập trình Đa luồng (Multi-threading)</strong>. Đây là kỹ thuật cho phép một chương trình có thể chia công việc của mình thành nhiều phần nhỏ, gọi là các <strong>luồng (threads)</strong>, và thực thi chúng đồng thời trên nhiều lõi khác nhau, từ đó tăng tốc độ xử lý và cải thiện hiệu năng tổng thể của ứng dụng.</p>
					</div>
                </div>
            </div>
            <hr class="my-8">
            <div>
                <h4 class="font-bold text-xl mb-3 text-cyan-700 text-center">1.2. Phân biệt Concurrency (Đồng thời) và Parallelism (Song song)</h4>
                <div class="grid md:grid-cols-2 gap-8 mt-4">
                    <div class="bg-cyan-50 border border-cyan-200 p-4 rounded-lg">
                        <h5 class="font-semibold text-lg">Concurrency (Đồng thời)</h5>
                        <p class="text-gray-700 mt-2 text-justify">Là khả năng quản lý và xử lý nhiều tác vụ <strong>dường như cùng một lúc</strong>. Các tác vụ này có thể bắt đầu, chạy, và hoàn thành trong các khoảng thời gian chồng chéo nhau. Trên một hệ thống chỉ có một lõi CPU, tính đồng thời được thực hiện thông qua một kỹ thuật gọi là <strong>chuyển đổi ngữ cảnh (context switching)</strong>. Hệ điều hành sẽ cấp phát cho mỗi tác vụ một khoảng thời gian rất nhỏ để chạy trên CPU, sau đó nhanh chóng chuyển sang tác vụ tiếp theo. Quá trình chuyển đổi này diễn ra nhanh đến mức người dùng có <strong>cảm giác như nhiều tác vụ đang chạy cùng lúc.</strong></p>
                        <p class="mt-2 text-sm text-justify"><strong>Ví dụ:</strong> Một người đầu bếp vừa giám sát nồi súp đang sôi, vừa tranh thủ thái rau củ. Người đầu bếp không làm cả hai việc chính xác tại cùng một thời điểm, mà liên tục chuyển sự chú ý và hành động qua lại giữa hai công việc đó.</p>
                    </div>
                    <div class="bg-emerald-50 border border-emerald-200 p-4 rounded-lg">
                        <h5 class="font-semibold text-lg">Parallelism (Song song)</h5>
                        <p class="text-gray-700 mt-2 text-justify">Là khả năng thực thi <strong>nhiều tác vụ</strong> chính xác tại cùng một thời điểm. Điều này chỉ có thể xảy ra trên một hệ thống phần cứng có nhiều hơn một đơn vị xử lý, chẳng hạn như <strong>CPU đa lõi</strong>. </p>
                        <p class="mt-2 text-sm text-justify"><strong>Ví dụ:</strong> Hai đầu bếp, một người chỉ nấu súp, người kia chỉ thái rau, cả hai cùng làm việc của mình trong cùng một khoảng thời gian.</p>
                    </div>
                </div>
				<p class="mt-6 text-justify text-gray-700">Điều quan trọng cần nhấn mạnh là sự khác biệt giữa hai khái niệm này. <strong>Lập trình đồng thời (Concurrency)</strong> là một khái niệm thuộc về thiết kế phần mềm; nó là cách chúng ta cấu trúc một chương trình để có thể xử lý nhiều luồng công việc một cách độc lập, nó là một vấn đề thuộc về logic của ứng dụng. Ngược lại, <strong>thực thi song song (Parallelism)</strong> là một hiện tượng thuộc về phần cứng và môi trường thực thi. Nó xảy ra khi các đơn vị công việc được cấu trúc đồng thời đó thực sự được thực thi trên các lõi CPU riêng biệt tại cùng một thời điểm.</p>
				<p class="mt-6 text-justify text-gray-700">Do đó, có thể nói rằng, lập trình viên viết mã đồng thời, nhưng việc mã đó có chạy song song hay không phụ thuộc vào nền tảng phần cứng và cách hệ điều hành lập lịch. Một chương trình được thiết kế tốt về mặt đồng thời có thể chạy hiệu quả trên CPU đơn lõi (thông qua chuyển đổi ngữ cảnh) và sẽ tự động được hưởng lợi về hiệu năng khi chạy trên CPU đa lõi (thông qua thực thi song song). <strong>Lập trình đa luồng</strong> chính là công cụ để chúng ta xây dựng nên cấu trúc đồng thời đó.</p>
            </div>
        </section>

        <section id="part2" class="py-12">
            <h3 class="text-3xl font-bold text-center mb-8">2. Tiến trình (Process) và Luồng (Thread)</h3>
            <p class="text-center max-w-3xl mx-auto text-gray-600 mb-12">Để hiểu về đa luồng, trước tiên chúng ta cần phân biệt rõ hai khái niệm cốt lõi: <strong>Tiến trình (Process)</strong> - một chương trình đang chạy với không gian bộ nhớ riêng và <strong>Luồng (Thread)</strong> - một đơn vị thực thi bên trong tiến trình đó. Sự khác biệt cơ bản nằm ở cách chúng quản lý và chia sẻ tài nguyên.</p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-start">
                <div class="bg-white p-6 rounded-lg shadow-lg border border-gray-200">
                    <h4 class="font-bold text-xl mb-4 text-center text-red-600">Tiến trình (Process)</h4>
                    <p class="text-sm text-gray-700 mb-4 text-justify"><strong>Tiến trình (Process)</strong> là một thực thể của một chương trình đang được thực thi. Mỗi tiến trình là một môi trường thực thi hoàn chỉnh và độc lập, bao gồm:</p>
					<ul class="list-disc list-inside space-y-1 text-sm text-gray-700 mb-4 text-justify">
                        <li><strong>Không gian địa chỉ bộ nhớ ảo riêng biệt</strong>: Đây là đặc tính quan trọng nhất của một tiến trình. Mỗi tiến trình sở hữu một không gian bộ nhớ ảo độc lập, được hệ điều hành bảo vệ. Điều này có nghĩa là tiến trình A không thể truy cập trực tiếp vào dữ liệu trong bộ nhớ của tiến trình B và ngược lại. Sự cô lập này mang lại tính ổn định và an toàn cao cho hệ thống; nếu một tiến trình gặp lỗi và bị sập, nó sẽ không làm ảnh hưởng đến các tiến trình khác đang chạy.</li>
                        <li><strong>Tài nguyên hệ thống</strong>: Một tiến trình được cấp phát các tài nguyên riêng như mã chương trình (code segment), dữ liệu toàn cục (data segment), các file handles (các tệp đang mở), các kết nối mạng, và ít nhất một luồng thực thi (luồng chính).</li>
                        <li><strong>"Tính "nặng" (Heavyweight)</strong>: Việc tạo ra một tiến trình mới là một hoạt động tốn kém tài nguyên và thời gian. Hệ điều hành phải thực hiện nhiều công việc phức tạp như cấp phát không gian bộ nhớ ảo, tạo các cấu trúc dữ liệu quản lý (như Process Control Block - PCB), và nạp mã chương trình. Do đó, tiến trình được coi là một đơn vị "nặng".</li>
                     </ul>
					<img src="https://img.upanh.moe/JjPg6Yz8/0ff08e91ea72.png" alt="Minh họa về Tiến trình (Process)" border="0" style="display: block; margin-left: auto; margin-right: auto;">
                </div>
                <div class="bg-white p-6 rounded-lg shadow-lg border border-gray-200">
                    <h4 class="font-bold text-xl mb-4 text-center text-cyan-600">Luồng (Thread)</h4>
                    <p class="text-sm text-gray-700 mb-4 text-justify"><strong>Luồng (Thread)</strong>, hay còn gọi là tiểu trình, là đơn vị thực thi cơ bản nhất bên trong một tiến trình. Một tiến trình có thể chứa một hoặc nhiều luồng, tất cả cùng hoạt động trong môi trường do tiến trình đó tạo ra. Mỗi luồng có các thành phần riêng biệt để duy trì trạng thái thực thi của nó, bao gồm: </p>
					<ul class="list-disc list-inside space-y-1 text-sm text-gray-700 mb-4 text-justify">
                        <li><strong>ID Luồng (Thread ID)</strong>: Một định danh duy nhất trong tiến trình.</li>
                        <li><strong>Bộ đếm chương trình (Program Counter)</strong>: Chỉ đến lệnh tiếp theo sẽ được thực thi.</li>
                        <li><strong>Tập thanh ghi (Register Set)</strong>: Lưu trữ các giá trị tính toán tạm thời.</li>
						<li><strong>Tính "nhẹ" (Lightweight)</strong>: Do việc chia sẻ tài nguyên, việc tạo ra một luồng mới nhanh hơn và tốn ít tài nguyên hơn rất nhiều so với việc tạo một tiến trình mới. Việc chuyển đổi ngữ cảnh giữa các luồng trong cùng một tiến trình cũng nhanh hơn đáng kể. Vì vậy, luồng được coi là một đơn vị "nhẹ".</li>
                    </ul>
					<p class="text-sm text-gray-700 mb-4 text-justify">Điểm khác biệt cốt lõi và quan trọng nhất giữa luồng và tiến trình nằm ở cách chúng quản lý bộ nhớ. Trong khi mỗi tiến trình có không gian bộ nhớ riêng, thì tất cả các luồng trong cùng một tiến trình lại chia sẻ chung không gian địa chỉ bộ nhớ của tiến trình đó. Điều này bao gồm vùng mã, vùng dữ liệu, và các tài nguyên khác như file handles. </p>
					<img src="https://img.upanh.moe/FktGWR9J/6e32b9a6372b.png" alt="Minh họa về Luồng (Thread)" border="0" style="display: block; margin-left: auto; margin-right: auto;">
                </div>
            </div>
            <div class="mt-12">
                <h4 class="font-bold text-xl mb-4 text-cyan-700 text-center">So sánh giữa Tiến trình và Luồng</h4>
                <div class="overflow-x-auto rounded-lg shadow">
                    <table class="min-w-full bg-white">
                        <thead class="bg-gray-800 text-white">
                            <tr>
                                <th class="text-left py-3 px-4 uppercase font-semibold text-sm">Tiêu chí</th>
                                <th class="text-left py-3 px-4 uppercase font-semibold text-sm">Tiến trình (Process)</th>
                                <th class="text-left py-3 px-4 uppercase font-semibold text-sm">Luồng (Thread)</th>
                            </tr>
                        </thead>
                        <tbody class="text-gray-700">
							<tr class="border-b"><td class="py-3 px-4 font-semibold">Định nghĩa</td><td class="py-3 px-4">Một chương trình đang thực thi. Một thực thể độc lập được hệ điều hành quản lý.</td><td class="py-3 px-4">Một đơn vị thực thi trong một tiến trình. Là một phần của tiến trình.</td></tr>
                            <tr class="border-b"><td class="py-3 px-4 font-semibold">Không gian bộ nhớ</td><td class="py-3 px-4">Độc lập, riêng biệt và được bảo vệ. Mỗi tiến trình có không gian địa chỉ ảo của riêng mình.</td><td class="py-3 px-4">Chia sẻ chung không gian địa chỉ bộ nhớ (vùng mã, dữ liệu) với các luồng khác trong cùng tiến trình.</td></tr>
                            <tr class="bg-gray-50 border-b"><td class="py-3 px-4 font-semibold">Chi phí tạo</td><td class="py-3 px-4">Cao ("nặng"). Đòi hỏi hệ điều hành cấp phát nhiều tài nguyên.</td><td class="py-3 px-4">Thấp ("nhẹ"). Tái sử dụng tài nguyên của tiến trình cha.</td></tr>
                            <tr class="border-b"><td class="py-3 px-4 font-semibold">Chuyển đổi ngữ cảnh</td><td class="py-3 px-4">Chậm, chi phí cao. Cần lưu và phục hồi toàn bộ không gian bộ nhớ và tài nguyên.</td><td class="py-3 px-4">Nhanh, chi phí thấp. Chỉ cần lưu và phục hồi thanh ghi và ngăn xếp.</td></tr>
                            <tr class="bg-gray-50 border-b"><td class="py-3 px-4 font-semibold">Giao tiếp</td><td class="py-3 px-4">Phức tạp, cần các cơ chế giao tiếp liên tiến trình (IPC - Inter-Process Communication) do hệ điều hành cung cấp.</td><td class="py-3 px-4">Đơn giản, nhanh chóng thông qua việc đọc/ghi trực tiếp vào các biến và cấu trúc dữ liệu trong bộ nhớ chia sẻ.</td></tr>
                            <tr><td class="py-3 px-4 font-semibold">Mức độ độc lập & An toàn</td><td class="py-3 px-4">Cao. Lỗi ở một tiến trình (ví dụ: truy cập bộ nhớ không hợp lệ) không ảnh hưởng đến các tiến trình khác.</td><td class="py-3 px-4">Thấp. Lỗi ở một luồng (ví dụ: ghi đè dữ liệu quan trọng) có thể làm sập toàn bộ tiến trình và tất cả các luồng khác.</td></tr>
							<tr><td class="py-3 px-4 font-semibold">Mối quan hệ</td><td class="py-3 px-4">Các tiến trình là các thực thể ngang hàng, độc lập với nhau.</td><td class="py-3 px-4">Luồng là thành phần con, phụ thuộc vào tiến trình chứa nó. Nếu tiến trình kết thúc, tất cả luồng của nó cũng kết thúc.</td></tr>
                        </tbody>
                    </table>
                </div>
			</div>
			<div class="mt-4">
				<p class="text-gray-700 mb-2 text-justify">Từ bảng so sánh trên, một quy luật thiết kế cơ bản trong hệ thống máy tính được thể hiện rõ ràng: sự đánh đổi giữa An toàn/Cô lập (Isolation) và Hiệu quả/Chia sẻ (Efficiency).</p>
				<p class="text-gray-700 mb-2 text-justify">Các tiến trình được thiết kế để ưu tiên sự an toàn và cô lập. Việc mỗi tiến trình có một không gian bộ nhớ riêng biệt tạo ra một bức tường lửa vững chắc, ngăn chặn lỗi lan truyền giữa các ứng dụng. Tuy nhiên, sự an toàn này phải trả giá bằng hiệu suất: việc tạo mới, giao tiếp và chuyển đổi giữa các tiến trình đều rất tốn kém.</p>
				<p class="text-gray-700 mb-2 text-justify">Ngược lại, các luồng được thiết kế để ưu tiên hiệu quả và chia sẻ. Việc dùng chung bộ nhớ giúp tạo luồng cực kỳ nhanh, chuyển đổi ngữ cảnh gần như tức thời, và giao tiếp giữa các luồng hiệu quả tối đa. Nhưng hiệu quả này lại phải trả giá bằng sự an toàn. Vì không có bức tường nào ngăn cách các luồng, một luồng "xấu" có thể dễ dàng ghi đè lên dữ liệu mà một luồng khác đang sử dụng, gây ra các lỗi khó lường và có thể làm sập toàn bộ ứng dụng. Điều này đòi hỏi lập trình viên phải "lập trình một cách rất cẩn thận" khi làm việc với đa luồng.</p>
            </div>
        </section>
        
        <section id="part3" class="py-12 bg-white rounded-lg shadow-xl my-12 p-6 md:p-8">
            <h3 class="text-3xl font-bold text-center mb-2">3. Lập trình Đa luồng</h3>
			<h4 class="font-bold text-xl mb-3 text-cyan-700 text-center">3.1. Lợi ích của Đa luồng</h4>
            <p class="text-center max-w-3xl mx-auto text-gray-600 mb-12">Đa luồng không chỉ giúp tận dụng phần cứng hiện đại mà còn mang lại nhiều lợi ích thiết thực cho cả nhà phát triển và người dùng cuối.</p>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8">
                <div class="text-center p-4"><div class="flex items-center justify-center h-16 w-16 rounded-full bg-cyan-100 text-cyan-600 mx-auto mb-4 text-3xl">🚀</div><h4 class="font-bold text-lg mb-2">Tăng khả năng phản hồi</h4><p class="text-gray-600">Giao diện người dùng không bị "đơ" khi xử lý các tác vụ nặng ở luồng nền.</p></div>
                <div class="text-center p-4"><div class="flex items-center justify-center h-16 w-16 rounded-full bg-cyan-100 text-cyan-600 mx-auto mb-4 text-3xl">🔄</div><h4 class="font-bold text-lg mb-2">Chia sẻ tài nguyên hiệu quả</h4><p class="text-gray-600">Các luồng chia sẻ chung bộ nhớ, giúp việc trao đổi dữ liệu trở nên dễ dàng và nhanh chóng.</p></div>
                <div class="text-center p-4"><div class="flex items-center justify-center h-16 w-16 rounded-full bg-cyan-100 text-cyan-600 mx-auto mb-4 text-3xl">💰</div><h4 class="font-bold text-lg mb-2">Tính kinh tế</h4><p class="text-gray-600">Tạo một luồng tốn ít tài nguyên và thời gian hơn nhiều so với tạo một tiến trình mới.</p></div>
                <div class="text-center p-4"><div class="flex items-center justify-center h-16 w-16 rounded-full bg-cyan-100 text-cyan-600 mx-auto mb-4 text-3xl">⚙️</div><h4 class="font-bold text-lg mb-2">Khả năng mở rộng và tận dụng phần cứng</h4><p class="text-gray-600">Phân chia công việc cho các luồng chạy song song trên nhiều lõi CPU để tăng tốc độ tính toán.</p></div>
            </div>
			<div class="mt-4">
				<p class="text-gray-700 mb-2 text-justify"><strong>a) Tăng khả năng phản hồi (Responsiveness)</strong>: Đây là lợi ích dễ nhận thấy nhất đối với người dùng, đặc biệt trong các ứng dụng có giao diện đồ họa (GUI). Trong một ứng dụng đơn luồng, nếu một tác vụ tốn nhiều thời gian (ví dụ: tải một tệp tin lớn từ mạng, thực hiện một truy vấn cơ sở dữ liệu phức tạp, hay xử lý một hình ảnh lớn) được thực thi, toàn bộ ứng dụng sẽ bị "đơ" hoặc "treo". Người dùng không thể tương tác với giao diện, cửa sổ ứng dụng có thể chuyển sang màu trắng và hệ điều hành báo "Not Responding". Đa luồng giải quyết triệt để vấn đề này. Các tác vụ nặng có thể được chuyển sang một hoặc nhiều luồng nền (background threads). Trong khi đó, luồng chính (main thread), hay còn gọi là luồng giao diện người dùng (UI thread), vẫn hoàn toàn tự do để xử lý các sự kiện từ người dùng như nhấp chuột, gõ phím, cuộn trang. Điều này tạo ra một trải nghiệm mượt mà và liền mạch, ngay cả khi ứng dụng đang thực hiện những công việc phức tạp nhất. Ví dụ, một trình duyệt web đa luồng cho phép bạn tiếp tục cuộn và đọc một trang web trong khi các hình ảnh và video trên trang đó vẫn đang được tải về trong các luồng nền.</p>
				<p class="text-gray-700 mb-2 text-justify"><strong>b) Chia sẻ tài nguyên hiệu quả (Resource Sharing)</strong>: Theo mặc định, các tiến trình không chia sẻ bộ nhớ. Nếu cần trao đổi dữ liệu, chúng phải sử dụng các cơ chế IPC phức tạp và chậm chạp do hệ điều hành cung cấp. Ngược lại, các luồng trong cùng một tiến trình chia sẻ chung không gian bộ nhớ và tài nguyên. Điều này cho phép nhiều luồng có thể làm việc trên cùng một tập dữ liệu một cách dễ dàng và hiệu quả. Việc chia sẻ mã và dữ liệu không chỉ giúp tiết kiệm bộ nhớ mà còn đơn giản hóa việc lập trình các tác vụ cần sự phối hợp chặt chẽ.</p>
				<p class="text-gray-700 mb-2 text-justify"><strong>c) Hiệu quả về chi phí (Economical)</strong>: Như đã phân tích, việc tạo ra một tiến trình là một hoạt động tốn kém. Việc cấp phát bộ nhớ và tài nguyên cho mỗi tiến trình mới tiêu tốn đáng kể thời gian và tài nguyên hệ thống. Trong khi đó, việc tạo một luồng mới, do nó tái sử dụng tài nguyên của tiến trình mẹ, lại ít tốn kém hơn rất nhiều. Việc chuyển đổi ngữ cảnh giữa các luồng cũng nhanh hơn đáng kể so với giữa các tiến trình. Do đó, trong các ứng dụng cần xử lý đồng thời hàng trăm hoặc hàng ngàn tác vụ nhỏ, việc sử dụng luồng sẽ hiệu quả hơn rất nhiều so với việc tạo ra hàng trăm hoặc hàng ngàn tiến trình.</p>
				<p class="text-gray-700 mb-2 text-justify"><strong>d) Khả năng mở rộng và tận dụng phần cứng (Scalability)</strong>: Đây là lợi ích về mặt hiệu năng tính toán. Trên một hệ thống có nhiều bộ xử lý hoặc nhiều lõi, đa luồng cho phép các luồng thực sự chạy song song trên các lõi khác nhau. Một ứng dụng đơn luồng chỉ có thể chạy trên một CPU, bất kể hệ thống có bao nhiêu CPU sẵn có. Bằng cách chia một công việc lớn thành nhiều tác vụ nhỏ hơn và giao cho các luồng khác nhau xử lý, một ứng dụng đa luồng có thể hoàn thành công việc đó trong thời gian ngắn hơn nhiều. Khả năng này được gọi là khả năng mở rộng (scalability), vì hiệu năng của ứng dụng có thể tăng lên khi được chạy trên phần cứng mạnh hơn (nhiều lõi hơn).</p>
            </div>
             
            <div id="models" class="mt-16">
                <h4 class="font-bold text-xl mb-3 text-cyan-700 text-center">3.2. Các mô hình Đa luồng</h4>
                <p class="text-center max-w-3xl mx-auto text-gray-600 mb-12">Mối quan hệ ánh xạ giữa <strong> Luồng người dùng (User Threads)</strong> và <strong>Luồng nhân (Kernel Threads)</strong> quyết định mô hình đa luồng của một hệ thống.</p>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-8 text-center">
                    <div class="border p-4 rounded-lg">
						<h5 class="font-semibold text-lg">Many-to-One</h5>
						<p class="text-sm mt-2">Nhiều luồng người dùng ánh xạ vào một luồng nhân. Nhanh nhưng không tận dụng được đa lõi.</p>
						<img src="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter4/4_05_ManyToOne.jpg" alt="Minh họa về mô hình Many-to-One" border="0" style="display: block; margin-left: auto; margin-right: auto; margin-top: 15px;">
					</div>
                    <div class="border p-4 rounded-lg bg-cyan-50 border-cyan-300">
						<h5 class="font-semibold text-lg">One-to-One</h5>
						<p class="text-sm mt-2">Mỗi luồng người dùng ánh xạ tới một luồng nhân riêng biệt. Cho phép chạy song song.</p>
						<p class="text-sm mt-2"><strong>Phổ biến nhất hiện nay.</strong></p>
						<img src="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter4/4_06_OneToOne.jpg" alt="Minh họa về mô hình One-to-One" border="0" style="display: block; margin-left: auto; margin-right: auto; margin-top: 15px;">
					</div>
                    <div class="border p-4 rounded-lg">
						<h5 class="font-semibold text-lg">Many-to-Many</h5>
						<p class="text-sm mt-2">Nhiều luồng người dùng ánh xạ tới một số lượng luồng nhân nhỏ hơn. Linh hoạt nhưng phức tạp.</p>
						<img src="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter4/4_07_ManyToMany.jpg" alt="Minh họa về mô hình Many-to-Many" border="0" style="display: block; margin-left: auto; margin-right: auto; margin-top: 15px;">
					</div>
                </div>
            </div>

            <div id="lifecycle" class="mt-16">
                <h4 class="font-bold text-xl mb-3 text-cyan-700 text-center">3.3. Vòng đời của một Luồng (Thread Lifecycle)</h4>
                <p class="text-center max-w-3xl mx-auto text-gray-600 mb-12">Mỗi luồng trải qua nhiều trạng thái khác nhau từ khi được tạo ra cho đến khi kết thúc. Hiểu rõ vòng đời này là chìa khóa để quản lý và gỡ lỗi các ứng dụng đa luồng hiệu quả.</p>
                <div id="lifecycle-container" class="w-full max-w-4xl mx-auto flex flex-col items-center gap-y-4">
                    <div id="lifecycle-top-row" class="flex flex-wrap items-center justify-center gap-2 text-center text-sm w-full"></div>
                    <div class="w-full max-w-md h-12 relative">
                        <svg width="100%" height="100%" viewBox="0 0 400 60" preserveAspectRatio="xMidYMid meet" class="absolute top-0 left-0">
                            <defs>
                                <marker id="arrowhead" markerWidth="6" markerHeight="4" refX="5" refY="2" orient="auto">
                                    <polygon points="0 0, 6 2, 0 4" fill="#a0aec0"></polygon>
                                </marker>
                            </defs>
                        
                            <path d="M 260 2 L 205 52" stroke="#a0aec0" stroke-width="1.5" fill="none" marker-end="url(#arrowhead)"></path>
                            
                            <path d="M 195 52 L 100 5" stroke="#a0aec0" stroke-width="1.5" fill="none" marker-end="url(#arrowhead)"></path>
                        </svg>
                    </div>
                    <div id="lifecycle-bottom-row" class="flex items-center justify-center"></div>
                 </div>
                <div id="lifecycle-details" class="mt-8 bg-gray-50 p-6 rounded-lg shadow-inner border max-w-2xl mx-auto min-h-[100px]">
					<p class="text-gray-600">Chọn một trạng thái để xem mô tả.</p>
				</div>
            </div>
        </section>

        <section id="part4" class="py-12">
             <h3 class="text-3xl font-bold text-center mb-2">4. Những vấn đề thường gặp trong môi trường đa luồng</h3>
             <p class="text-center max-w-3xl mx-auto text-gray-600 mb-12">Sức mạnh của đa luồng đi kèm với những thách thức phức tạp. Gốc rễ của vấn đề đến từ <strong>trạng thái chia sẻ (shared state)</strong> - vùng dữ liệu mà nhiều luồng có thể truy cập.</p>
            
            <div class="bg-white rounded-lg shadow-xl p-6 md:p-8">
                <div class="mb-4 border-b border-gray-200">
                    <nav class="-mb-px flex space-x-8" aria-label="Tabs">
						<button id="tab-overall" class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-lg border-cyan-500 text-cyan-600">Tổng quan</button>
                        <button id="tab-race" class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-lg border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300">Điều kiện Tranh chấp (Race Condition)</button>
                        <button id="tab-deadlock" class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-lg border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300">Khóa chết (Deadlock)</button>
                        <button id="tab-other" class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-lg border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300">Vấn đề khác</button>
                    </nav>
                </div>
				
				<div id="content-tab-overall" class="mb-4 text-gray-700 text-justify">
					<p class="mb-4"><strong>Trạng thái chia sẻ</strong> là bất kỳ vùng dữ liệu, biến, đối tượng, hoặc tài nguyên nào (như một tệp tin, một kết nối cơ sở dữ liệu) có thể được truy cập hoặc sửa đổi bởi nhiều hơn một luồng. Trong một ứng dụng đa luồng, đây là vùng bộ nhớ chung mà tất cả các luồng trong cùng một tiến trình đều có thể "nhìn thấy" và "chạm vào".</p>
					<p class="mb-4">Khi một luồng chỉ đọc dữ liệu từ trạng thái chia sẻ, thường không có vấn đề gì xảy ra. Tuy nhiên, khi có ít nhất một luồng cố gắng sửa đổi (ghi) dữ liệu đó trong khi các luồng khác có thể đang đọc hoặc cũng đang ghi, các vấn đề nghiêm trọng có thể phát sinh.</p>
					<p>Để quản lý việc truy cập này, chúng ta định nghĩa một khái niệm gọi là <strong>Vùng găng (Critical Section)</strong>. Đây là một đoạn mã trong chương trình thực hiện việc truy cập hoặc sửa đổi trạng thái chia sẻ. Thách thức lớn nhất trong lập trình đa luồng là làm thế nào để đảm bảo rằng tại một thời điểm, chỉ có tối đa một luồng được phép thực thi bên trong vùng găng của nó. Nguyên tắc này được gọi là loại trừ tương hỗ (mutual exclusion).</p>
				</div>
				
                <div id="content-race" class="hidden text-justify">
					<p class="mb-4 text-gray-700"><strong>Điều kiện tranh chấp (Race Condition)</strong> là một trong những lỗi phổ biến và nguy hiểm nhất trong lập trình đa luồng. Nó xảy ra khi hành vi hoặc kết quả của một chương trình phụ thuộc vào thứ tự thực thi không thể đoán trước của các thao tác từ hai hoặc nhiều luồng đang cạnh tranh để truy cập cùng một tài nguyên chia sẻ. Khi các luồng "chạy đua" với nhau để cập nhật dữ liệu, kết quả cuối cùng có thể hoàn toàn sai lệch và không nhất quán.</p>
					
					<div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
						<div class="border p-4 rounded-lg bg-gray-100">
							<h4 class="font-semibold text-lg mb-4">Ví dụ: Giao dịch ngân hàng</h4>
							<p>Giả sử chúng ta có một tài khoản ngân hàng với số dư ban đầu là $1,000. Hai giao dịch xảy ra đồng thời:</p>
							<p><span class="font-bold text-red-700">Luồng A (Rút tiền)</span>: Cố gắng rút $100.</p>
							<p class="mb-4"><span class="font-bold text-green-700">Luồng B (Nạp tiền)</span>: Cố gắng nạp $200.
							Kết quả mong đợi sau khi cả hai giao dịch hoàn tất là $1,000 - $100 + $200 = $1,100.</p>
							<p>Tuy nhiên, thao tác "cập nhật số dư" không phải là một hành động đơn lẻ, không thể chia cắt (atomic). Nó thường bao gồm ba bước riêng biệt:</p>
							<p>1. Đọc giá trị số dư hiện tại từ bộ nhớ vào một thanh ghi của CPU.</p>
							<p>2. Thực hiện phép tính (cộng hoặc trừ) trên thanh ghi đó.</p>
							<p>3. Ghi giá trị mới từ thanh ghi trở lại bộ nhớ.</p>
						</div>
						<div class="border p-4 rounded-lg bg-gray-100">
							<p class="font-medium mb-2">Số dư tài khoản: <span id="counter-value" class="font-bold text-2xl text-cyan-700">1000</span></p>
							<div id="simulation-controls" class="flex items-center gap-2 mb-4">
								<button id="start-step-unsynced" class="flex-grow bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded transition-colors">Bắt đầu (Không đồng bộ)</button>
								<button id="start-step-synced" class="flex-grow bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded transition-colors">Bắt đầu (Có đồng bộ)</button>
								<button id="run-next-step" class="hidden flex-grow bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition-colors">Bước tiếp theo &rarr;</button>
								<button id="reset-counter" class="hidden bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded transition-colors">Reset</button>
							</div>
							<div id="simulation-log" class="text-sm bg-sky-100 p-2 rounded h-40 overflow-y-auto font-mono">Nhấn nút để mô phỏng giao dịch...<br>Mong đợi: 1000 - 100 + 200 = 1100.</div>
						</div>
					</div>
				
					<p class="mt-4 mb-4 text-gray-700">Kết quả cuối cùng là <strong>$900</strong>. Giao dịch nạp tiền $200 của Luồng B đã hoàn toàn bị "mất". Nếu thứ tự thực thi hơi khác một chút, kết quả cuối cùng có thể là $1,200 (giao dịch rút tiền bị mất). Cả hai kết quả đều sai. Đây chính là sự <strong>không nhất quán dữ liệu (Data Inconsistency)</strong> gây ra bởi race condition.</p>
					<p class="mb-4 text-gray-700">Bản chất của race condition khiến nó trở thành một loại lỗi logic <strong>"ẩn"</strong>, cực kỳ khó phát hiện và tái tạo. Không giống như các lỗi rõ ràng như chia cho không, race condition không phải lúc nào cũng xảy ra. Nó phụ thuộc hoàn toàn vào một chuỗi sự kiện "không may mắn" trong việc lập lịch của hệ điều hành, vốn bị ảnh hưởng bởi nhiều yếu tố như tải hệ thống, số lượng lõi CPU, và thời gian thực thi của các tác vụ khác. Một chương trình có thể chạy đúng 100 lần trong môi trường thử nghiệm (QA) nhưng lại gặp lỗi ngay trong lần chạy đầu tiên trên môi trường sản phẩm (production) chỉ vì sự khác biệt về tải.</p>
					<p class="mb-4 text-gray-700">Điều này làm cho việc <strong>gỡ lỗi (debugging)</strong> trở nên vô cùng khó khăn. Việc sử dụng các công cụ gỡ lỗi truyền thống như đặt điểm dừng (breakpoints) có thể làm thay đổi hoàn toàn thứ tự và thời gian thực thi của các luồng, khiến cho lỗi không còn tái hiện được nữa. Do đó, cách tiếp cận hiệu quả nhất không phải là "săn lùng" và sửa chữa các race condition đã xảy ra, mà là thiết kế hệ thống một cách phòng ngừa. Bằng cách sử dụng các cơ chế đồng bộ hóa (sẽ được thảo luận trong <strong>Phần 5</strong>), chúng ta có thể loại bỏ hoàn toàn khả năng xảy ra race condition ngay từ đầu, đảm bảo tính đúng đắn của chương trình trong mọi kịch bản thực thi.</p>
				</div>
				
                <div id="content-deadlock" class="hidden">
					<p class="mb-4 text-gray-700"><strong>Khóa chết (Deadlock)</strong> là một tình huống bế tắc trong đó hai hoặc nhiều luồng bị chặn vô thời hạn, mỗi luồng đang chờ một tài nguyên mà một luồng khác trong nhóm đang giữ.  Khi deadlock xảy ra, các luồng liên quan sẽ ngừng hoạt động vĩnh viễn, thường dẫn đến việc chương trình bị treo.</p>
					<p class="mb-4">Để một deadlock xảy ra, bốn điều kiện sau đây, được gọi là <strong>điều kiện Coffman</strong>, phải được thỏa mãn đồng thời :</p>
					<p><strong>1. Mutual Exclusion (Loại trừ tương hỗ)</strong>: Ít nhất một tài nguyên phải ở trạng thái không thể chia sẻ. Tức là, tại một thời điểm, chỉ có một luồng được phép sử dụng tài nguyên đó.</p>
					<p><strong>2. Hold and Wait (Giữ và chờ)</strong>: Một luồng phải đang giữ ít nhất một tài nguyên và đồng thời yêu cầu thêm các tài nguyên khác đang bị các luồng khác giữ.</p>
					<p><strong>3. No Preemption (Không thu hồi)</strong>: Tài nguyên không thể bị thu hồi một cách cưỡng bức từ luồng đang giữ nó. Một tài nguyên chỉ có thể được giải phóng một cách tự nguyện bởi luồng đang giữ nó sau khi luồng đó đã hoàn thành công việc.</p>
					<p class="mb-4"><strong>4. Circular Wait (Chờ đợi vòng tròn)</strong>: Tồn tại một chuỗi các luồng đang chờ đợi {T<sub>0</sub>, T<sub>1</sub>,..., T<sub>n</sub>} sao cho T<sub>0</sub> đang chờ một tài nguyên do T<sub>1</sub> giữ, T<sub>1</sub> đang chờ một tài nguyên do T<sub>2</sub> giữ,..., và Tn đang chờ một tài nguyên do T<sub>0</sub> giữ, tạo thành một chu kỳ khép kín.</p>
					<h4 class="font-semibold text-lg mb-4">Ví dụ mô phỏng: Bài toán các Triết gia ăn tối (Dining Philosophers Problem)</h4>
					<p class="mb-4">Có năm triết gia ngồi quanh một chiếc bàn tròn. Trước mặt mỗi người là một đĩa mỳ spaghetti. Giữa mỗi cặp triết gia liền kề có một chiếc nĩa. Tổng cộng có năm triết gia và năm chiếc nĩa. Các triết gia luân phiên giữa hai trạng thái: suy nghĩ và ăn. Để ăn được mỳ, một triết gia cần phải có cả hai chiếc nĩa: chiếc bên trái và chiếc bên phải của mình.</p>
					<p><strong>Kịch bản Deadlock</strong>: Hãy tưởng tượng một kịch bản mà mỗi triết gia đều tuân theo một thuật toán đơn giản:</p>
					<p>1. Suy nghĩ một lúc.</p>
					<p>2. Khi đói, cầm chiếc nĩa bên trái của mình.</p>
					<p>3. Sau đó, cầm chiếc nĩa bên phải của mình.<p>
					<p>4. Ăn.</p>
					<p>5. Đặt cả hai chiếc nĩa xuống.</p>
					<p class="mb-4">Nếu tất cả năm triết gia cùng lúc cảm thấy đói và đồng thời thực hiện bước 2 (cầm chiếc nĩa bên trái), thì mỗi triết gia sẽ giữ một chiếc nĩa. Bây giờ, tất cả họ sẽ chuyển sang bước 3 và cố gắng cầm chiếc nĩa bên phải. Tuy nhiên, chiếc nĩa bên phải của mỗi người lại chính là chiếc nĩa bên trái của người hàng xóm, và nó đã bị cầm mất. Do đó, tất cả năm triết gia sẽ ngồi chờ đợi vĩnh viễn chiếc nĩa thứ hai, không ai có thể ăn và cũng không ai chịu nhả chiếc nĩa mình đang cầm ra. Đây là một tình huống deadlock hoàn hảo, thỏa mãn cả <strong>bốn điều kiện Coffman</strong>.</p>

				
					<div class="flex flex-col items-center">
						<div id="deadlock-circle"></div>
						<div class="flex space-x-2 mt-4"> 
							<button id="run-deadlock-step" class="bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded transition-colors mb-2">Chạy</button>
							<button id="reset-deadlock" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded transition-colors mb-2">Reset</button>
						</div>
						<p id="deadlock-status" class="text-lg font-medium h-8 text-center"></p>
					</div>
					
					<div class="border p-4 rounded-lg bg-gray-50 mt-6">
					<h5 class="font-semibold mb-2">Giải pháp 1: Phân cấp tài nguyên (Resource Hierarchy) </h5><p class="text-sm mb-2">Phá vỡ điều kiện Chờ đợi vòng tròn: Một giải pháp thanh lịch là đánh số các chiếc nĩa từ 1 đến 5. Sau đó, đặt ra một quy tắc: mỗi triết gia phải luôn cố gắng cầm chiếc nĩa có số hiệu nhỏ hơn trước, sau đó mới đến chiếc nĩa có số hiệu lớn hơn. Với quy tắc này, bốn triết gia đầu tiên (1 đến 4) sẽ cầm chiếc nĩa bên trái của họ (tương ứng là nĩa 1, 2, 3, 4). Tuy nhiên, triết gia thứ năm, ngồi giữa nĩa 5 và nĩa 1, sẽ phải cố gắng cầm nĩa 1 trước. Nhưng nĩa 1 đã bị triết gia đầu tiên cầm. Do đó, triết gia thứ năm sẽ bị chặn ngay từ đầu, không thể cầm được chiếc nĩa nào. Điều này có nghĩa là chiếc nĩa 5 vẫn còn tự do. Triết gia thứ tư, sau khi đã cầm được nĩa 4, sẽ có thể cầm tiếp nĩa 5 và bắt đầu ăn. Sau khi ăn xong, ông ta sẽ nhả cả hai nĩa ra, cho phép các triết gia khác tiếp tục. Bằng cách áp đặt một thứ tự, chúng ta đã phá vỡ chu kỳ chờ đợi.</p>
					<h5 class="font-semibold mb-2">Giải pháp 2: Người phục vụ (Arbitrator/Waiter)</h5><p class="text-sm mb-2">Phá vỡ điều kiện Giữ và chờ: Một giải pháp khác là giới thiệu một "người phục vụ" (có thể được hiện thực hóa bằng một khóa duy nhất, gọi là mutex). Trước khi cầm bất kỳ chiếc nĩa nào, một triết gia phải xin phép người phục vụ. Người phục vụ chỉ cho phép một triết gia cầm nĩa tại một thời điểm. Sau khi triết gia đó đã lấy đủ cả hai nĩa và ăn xong, ông ta sẽ báo cho người phục vụ biết. Bằng cách này, chúng ta đảm bảo không bao giờ xảy ra tình huống một triết gia "giữ" một nĩa và "chờ" nĩa còn lại, vì việc lấy cả hai nĩa được coi là một hành động nguyên tử dưới sự giám sát của người phục vụ.</p>
					</div>
				</div>
                
				<div id="content-other" class="hidden">
					<div class="grid md:grid-cols-2 gap-6">
						<div class="bg-rose-50 border border-rose-200 p-4 rounded-lg">
							<h5 class="font-semibold text-lg">Starvation (Chết đói)</h5>
							<p class="text-gray-700 mt-2">Đây là tình huống một luồng không bao giờ được cấp phát các tài nguyên cần thiết để thực thi, mặc dù các tài nguyên đó vẫn được cấp phát cho các luồng khác. Luồng đó bị "bỏ đói" và không thể tiến triển. Điều này thường xảy ra trong các hệ thống có cơ chế ưu tiên. Nếu các luồng có độ ưu tiên cao liên tục xuất hiện và chiếm dụng CPU hoặc tài nguyên, một luồng có độ ưu tiên thấp có thể không bao giờ có cơ hội được chạy.</p>
						</div>
						<div class="bg-indigo-50 border border-indigo-200 p-4 rounded-lg">
							<h5 class="font-semibold text-lg">Priority Inversion (Đảo ngược Ưu tiên)</h5>
							<p class="text-gray-700 mt-2">Một luồng có độ ưu tiên thấp đang giữ một tài nguyên mà luồng có độ ưu tiên cao cần, nhưng lại bị một luồng có độ ưu tiên trung bình chiếm quyền thực thi, khiến luồng ưu tiên cao phải chờ đợi một cách vô lý.</p>
						</div>
					</div>
				</div>
            </div>
        </section>
        
        <section id="part5" class="py-12 bg-white rounded-lg shadow-xl my-12 p-6 md:p-8">
			<h3 class="text-3xl font-bold text-center mb-2">5. Các cơ chế Đồng bộ hóa</h3>
			<p class="text-center max-w-3xl mx-auto text-gray-600 mb-12">Để giải quyết các thách thức đã nêu, các ngôn ngữ lập trình và hệ điều hành cung cấp một bộ công cụ mạnh mẽ gọi là các <strong>cơ chế đồng bộ hóa (synchronization primitives)</strong>. Việc lựa chọn và sử dụng đúng công cụ cho từng vấn đề là kỹ năng cốt lõi của một lập trình viên đa luồng.</p>

			<div class="border-t pt-8 mt-8 text-justify">
				<h4 class="font-bold text-2xl mb-3 text-cyan-700">5.1. Mutex (Mutual Exclusion)</h4>
				<p class="mb-4"><strong>Mutex</strong> là cơ chế khóa cơ bản và phổ biến nhất, được thiết kế để thực thi nguyên tắc <strong>loại trừ tương hỗ (mutual exclusion)</strong>. Tên của nó là viết tắt của <strong>"Mutual Exclusion"</strong>. Một mutex có thể được hình dung như <strong>một chiếc chìa khóa</strong> của một căn phòng (vùng găng). Trước khi vào phòng, một luồng phải lấy được chìa khóa. Chỉ có một chiếc chìa khóa duy nhất, vì vậy tại một thời điểm chỉ có một luồng có thể ở trong phòng. Các luồng khác đến sau sẽ phải xếp hàng đợi bên ngoài cho đến khi luồng bên trong ra ngoài và trả lại chìa khóa.</p>
				<p><strong>Cách hoạt động:</strong> Một mutex có hai trạng thái cơ bản: đã khóa (locked) và chưa khóa (unlocked).</p>
				
				<ul class="list-disc list-inside space-y-1 text-gray-700 mb-4">
					<li><code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">lock()</code>: Một luồng gọi hàm này để yêu cầu quyền sở hữu mutex. Nếu mutex đang ở trạng thái chưa khóa, luồng đó sẽ khóa nó lại và tiếp tục thực thi vùng găng. Nếu mutex đã bị một luồng khác khóa, luồng gọi lock() sẽ bị chặn (blocked) và đưa vào hàng đợi cho đến khi mutex được giải phóng.</li>
					<li><code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">unlock()</code>: Sau khi hoàn thành công việc trong vùng găng, luồng phải gọi hàm này để giải phóng mutex, đưa nó về trạng thái chưa khóa và cho phép một luồng khác trong hàng đợi có thể chiếm hữu nó.</li>
				</ul>
				
				<p><strong>Hướng dẫn trong C++:</strong></p>
				<p class="mb-4">Thư viện chuẩn C++ cung cấp <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::mutex</code> trong header <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">&lt;mutex&gt;</code>. Tuy nhiên, việc sử dụng trực tiếp <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">lock()</code> và <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">unlock()</code> thủ công tiềm ẩn nhiều rủi ro. Nếu một ngoại lệ (exception) xảy ra bên trong vùng găng, câu lệnh <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">unlock()</code> có thể bị bỏ qua, khiến mutex bị khóa vĩnh viễn và gây ra deadlock.</p>
				<p>Để giải quyết vấn đề này, C++ khuyến khích sử dụng mẫu thiết kế RAII (Resource Acquisition Is Initialization). Hai lớp <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::lock_guard</code> và <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::unique_lock</code> được cung cấp để tự động quản lý vòng đời của mutex:</p>
				<ul class="list-disc list-inside space-y-1 text-gray-700 mb-4">
					<li><code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::lock_guard</code>: Là lựa chọn đơn giản và hiệu quả nhất. Khi một đối tượng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::lock_guard</code> được tạo, nó sẽ tự động gọi <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">lock()</code> trên mutex được cung cấp. Khi đối tượng này ra khỏi phạm vi (scope), hàm hủy của nó sẽ tự động gọi <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">unlock()</code>. Điều này đảm bảo mutex luôn được giải phóng một cách an toàn, ngay cả khi có exception.</li>
					<li><code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::unique_lock</code>: Linh hoạt hơn <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::lock_guard</code> nhưng cũng phức tạp và có chi phí cao hơn một chút. Nó cho phép các thao tác nâng cao như khóa và mở khóa một cách tường minh, thử khóa mà không bị chặn (try_lock), và chuyển quyền sở hữu khóa. Nó đặc biệt cần thiết khi sử dụng với biến điều kiện (condition variables).</li>
				</ul>

				
				<h5 class="font-semibold text-lg text-cyan-700">Ví dụ 1:</h5>
				<p class="mb-4 text-gray-700">Hãy xem lại vấn đề race condition với biến đếm.</p>
        
				<div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
					<div class="code-container">
						<p class="font-medium mb-2">Mã bị lỗi (Race Condition):</p>
						<div class="code-block" data-example-id="race-condition-error">
<pre><code><span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;iostream&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;thread&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;vector&gt;</span>

<span style="color: #d19a66;">long long</span> counter = <span style="color: #d19a66;">0</span>;

<span style="color: #c678dd;">void</span> <span style="color: #61afef;">increment</span>() {
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">100000</span>; ++i) {
        counter++; <span style="color: #e06c75;">// Thao tác này không nguyên tử</span>
    }
}

<span style="color: #d19a66;">int</span> <span style="color: #61afef;">main</span>() {
    std::vector&lt;std::thread&gt; threads;
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">10</span>; ++i) {
        threads.push_back(std::thread(increment));
    }

    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">auto</span>&amp; th : threads) {
        th.join();
    }

    std::cout &lt;&lt; <span style="color: #98c379;">"Final counter: "</span> &lt;&lt; counter &lt;&lt; std::endl; <span style="color: #5c6370;">// Kết quả thường &lt; 1,000,000</span>
    <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">0</span>;
}
</code></pre>
						</div>
						<div class="explanation-panel hidden mt-4 border-l-4 border-sky-500 bg-sky-50 p-4 rounded-r-lg text-gray-700">
							<h6 class="font-bold text-lg mb-2 text-sky-800">Giải thích Lỗi</h6>
							<p class="mb-2">Đoạn code này tạo ra 10 luồng, mỗi luồng cố gắng tăng biến <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">counter</code> lên 100,000 lần. Tuy nhiên, do không có cơ chế bảo vệ, các luồng sẽ "giẫm chân" lên nhau, gây ra mất mát dữ liệu.</p>
							<p class="mb-2">Vấn đề nằm ở dòng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">counter++</code>. Dù trông có vẻ đơn giản, với CPU nó thực chất là một chuỗi 3 bước:</p>
							<ol class="list-decimal list-inside space-y-1 mb-2 ml-4">
								<li><strong>Đọc (Read):</strong> Đọc giá trị hiện tại của <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">counter</code> từ bộ nhớ vào một thanh ghi.</li>
								<li><strong>Sửa (Modify):</strong> Tăng giá trị trong thanh ghi lên 1.]</li>
								<li><strong>Ghi (Write):</strong> Ghi giá trị mới từ thanh ghi trở lại vào biến <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">counter</code> trong bộ nhớ.</li>
							</ol>
							<p class="mb-2">Tình huống tranh chấp (<strong>Race Condition</strong>) xảy ra như sau:</p>
							<ol class="list-decimal list-inside space-y-1 mb-2 ml-4">
								<li>Luồng A đọc <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">counter</code> (giả sử là 50). </li>
								<li>Hệ điều hành ngắt quãng Luồng A và chuyển sang Luồng B.</li>
								<li>Luồng B cũng đọc <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">counter</code> (vẫn là 50).</li>
								<li>Luồng B tăng giá trị đọc được lên 51 và ghi 51 vào <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">counter</code>.</li>
								<li>Hệ điều hành chuyển lại cho Luồng A.</li>
								<li>Luồng A không biết giá trị đã bị thay đổi, nó tiếp tục từ bước của mình, tăng giá trị nó đã đọc (50) lên 51 và cũng ghi 51 vào <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">counter</code>.</li>
							</ol>
							<p><strong>Kết quả:</strong> Cả hai luồng đều đã thực thi, nhưng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">counter</code> chỉ tăng lên 1 lần. Một lần tăng đã bị "mất". Với 10 luồng chạy song song, việc này xảy ra liên tục, dẫn đến kết quả cuối cùng thấp hơn nhiều so với 1,000,000.</p>
						</div>
					</div>
					<div class="code-container">
						<p class="font-medium mb-2">Mã đã được sửa bằng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::mutex</code> và <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::lock_guard</code>:</p>
						<div class="code-block" data-example-id="mutex-fix">
<pre><code><span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;iostream&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;thread&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;vector&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;mutex&gt;</span>

<span style="color: #d19a66;">long long</span> counter = <span style="color: #d19a66;">0</span>;
std::mutex mtx; <span style="color: #5c6370;">// Khai báo mutex</span>

<span style="color: #c678dd;">void</span> <span style="color: #61afef;">increment_safe</span>() {
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">100000</span>; ++i) {
        <span style="color: #98c379;">std::lock_guard&lt;std::mutex&gt; lock(mtx);</span> <span style="color: #5c6370;">// Khóa mutex trong scope này</span>
        counter++; <span style="color: #5c6370;">// Vùng găng, được bảo vệ</span>
    } <span style="color: #5c6370;">// lock_guard bị hủy, mutex tự động được unlock</span>
}

<span style="color: #d19a66;">int</span> <span style="color: #61afef;">main</span>() {
    std::vector&lt;std::thread&gt; threads;
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">10</span>; ++i) {
        threads.push_back(std::thread(increment_safe));
    }

    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">auto</span>&amp; th : threads) {
        th.join();
    }

    std::cout &lt;&lt; <span style="color: #98c379;">"Final counter: "</span> &lt;&lt; counter &lt;&lt; std::endl; <span style="color: #5c6370;">// Kết quả luôn là 1,000,000</span>
    <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">0</span>;
}
</code></pre>
						</div>
						<div class="explanation-panel hidden mt-4 border-l-4 border-sky-500 bg-sky-50 p-4 rounded-r-lg text-gray-700">
							<h6 class="font-bold text-lg mb-2 text-sky-800">Giải thích Giải pháp</h6>
							<p class="mb-2">Đoạn code này khắc phục vấn đề trên bằng cách sử dụng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::mutex</code> (Mutual Exclusion - Loại trừ tương hỗ) để bảo vệ vùng code nguy hiểm (<code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">counter++</code>).</p>
							<p class="mb-2">Nó hoạt động như thế nào?</p>
							<ol class="list-decimal list-inside space-y-2 mt-2">
								<li><strong><code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::mutex mtx;</code></strong>: Tưởng tượng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">mtx</code> như một chiếc chìa khóa của một căn phòng.</li>
								<li><strong><code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::lock_guard&lt;std::mutex&gt; lock(mtx);</code></strong>: Khi một luồng đến dòng này, nó sẽ cố gắng lấy chiếc chìa khóa (<code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">mtx.lock()</code>).
									<ul class="list-disc list-inside ml-4 mt-1">
										<li>Nếu chìa khóa đang có sẵn, luồng sẽ lấy nó, đi vào "vùng găng" (đoạn code bên trong), và thực hiện <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">counter++</code>.</li>
										<li>Nếu một luồng khác đang giữ chìa khóa, luồng này sẽ phải đứng đợi cho đến khi chìa khóa được trả lại.</li>
									</ul>
								</li>
								<li><strong>Kết thúc scope:</strong> Khi luồng thực thi xong <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">counter++</code> và đi đến dấu <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">}</code> của vòng lặp, đối tượng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">lock_guard</code> bị hủy. Trong hàm hủy của nó, nó sẽ tự động trả lại chìa khóa (<code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">mtx.unlock()</code>). Lúc này, một luồng khác đang đợi có thể lấy chìa khóa và đi vào.</li>
							</ol>
							<p class="mt-2">Cơ chế này đảm bảo rằng chuỗi thao tác Đọc-Sửa-Ghi đối với <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">counter</code> không bao giờ bị xen ngang bởi luồng khác, giúp thao tác này trở nên "nguyên tử" và bảo toàn dữ liệu. Việc sử dụng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::lock_guard</code> được khuyến khích vì nó đảm bảo mutex luôn được giải phóng, ngay cả khi có lỗi xảy ra (exception), tránh được tình trạng <strong>deadlock</strong>.</p>
						</div>
					</div>
				</div>
			</div>

			<div class="border-t pt-8 mt-8 text-justify">
				<h4 class="font-bold text-2xl mb-3 text-cyan-700">5.2. Semaphore</h4>
				<p class="mb-4"><strong>Semaphore</strong> là một cơ chế tổng quát hơn mutex, hoạt động như một biến đếm được bảo vệ dùng để quản lý quyền truy cập vào một nhóm các tài nguyên có số lượng giới hạn. Trong khi mutex chỉ cho phép một luồng truy cập, semaphore cho phép tối đa <strong>N luồng truy cập đồng thời</strong>, với N là giá trị khởi tạo của semaphore.</p>
				<p><strong>Cách hoạt động</strong>: Semaphore hỗ trợ hai thao tác chính (tên gọi có thể khác nhau tùy theo hệ thống):</p>
				<ul class="list-disc list-inside space-y-1 text-gray-700 mb-4">
					<li><code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">acquire()</code>(còn gọi là <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">wait()</code> hoặc <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">P()</code>): Cố gắng "lấy" một tài nguyên. Thao tác này sẽ kiểm tra bộ đếm của semaphore. Nếu bộ đếm lớn hơn 0, nó sẽ giảm bộ đếm đi 1 và cho phép luồng tiếp tục. Nếu bộ đếm bằng 0 (tức là tất cả tài nguyên đã được sử dụng), luồng sẽ bị chặn cho đến khi có một tài nguyên được giải phóng.</li>
					<li><code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">release()</code>(còn gọi là <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">signal()</code> hoặc <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">V()</code>): "Trả lại" một tài nguyên. Thao tác này tăng bộ đếm của semaphore lên 1. Nếu có các luồng đang bị chặn chờ tài nguyên, một trong số chúng sẽ được đánh thức.</li>
				</ul>

				<p><strong>Phân loại</strong>:</p>
				<ul class="list-disc list-inside space-y-1 text-gray-700 mb-4">
					<li><strong>Semaphore Đếm (Counting Semaphore)</strong>: Bộ đếm có thể là bất kỳ số nguyên không âm nào. Đây là loại semaphore tổng quát, dùng để giới hạn số lượng luồng truy cập đồng thời. Ví dụ: một ứng dụng có một pool 5 kết nối cơ sở dữ liệu có thể sử dụng một semaphore được khởi tạo với giá trị 5 để đảm bảo không quá 5 luồng sử dụng kết nối cùng lúc.</li>
					<li><strong>Semaphore Nhị phân (Binary Semaphore)</strong>: Một trường hợp đặc biệt của semaphore đếm, trong đó bộ đếm chỉ có thể nhận giá trị 0 hoặc 1. Nó hoạt động rất giống với mutex. Tuy nhiên, có một khác biệt quan trọng: với mutex, luồng đã khóa (lock) nó phải là luồng giải phóng (unlock) nó. Với semaphore, một luồng có thể gọi <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">release()</code> ngay cả khi nó không phải là luồng đã gọi <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">acquire()</code> trước đó. Điều này cho phép semaphore được sử dụng trong các kịch bản báo hiệu phức tạp hơn.</li>
				</ul>
				
				<p><strong>Hướng dẫn trong C++ (từ C++20)</strong>:</p>
				<p>Thư viện chuẩn C++20 đã chính thức giới thiệu semaphore trong header &lt;semaphore&gt;:</p>
				<ul class="list-disc list-inside space-y-1 text-gray-700 mb-4">
					<li><code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::counting_semaphore</code>: Dành cho semaphore đếm.</li>
					<li><code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::binary_semaphore</code>: Là một bí danh (alias) cho <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::counting_semaphore</code>. Nghĩa là <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::binary_semaphore</code> chính là <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::counting_semaphore</code> nhưng được giới hạn tối đa bằng 1.</li>
				</ul>
				
				<div class="code-container">
					<h5 class="font-semibold text-lg mb-2 text-cyan-700">Ví dụ 2:</h5>
                    <p class="mb-4 text-gray-700">Ví dụ sau sử dụng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::counting_semaphore</code> để giới hạn số lượng "worker" có thể thực hiện một tác vụ tốn thời gian cùng một lúc. Dù 10 luồng được tạo ra, nhưng tại bất kỳ thời điểm nào cũng chỉ có tối đa 3 luồng thực sự "làm việc".</p>
                    <p class="mt-3 text-gray-500 text-sm italic">Lưu ý: Sử dụng C++20 để dùng Semaphore: <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">g++ file_name.cpp -o file_name.exe -std=c++20 -pthread</code></p>

                    <div class="code-block" data-example-id="semaphore-worker">
<pre><code><span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;iostream&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;thread&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;vector&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;semaphore&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;chrono&gt;</span>

<span style="color: #5c6370;">// Giới hạn chỉ có 3 worker được chạy đồng thời</span>
std::counting_semaphore&lt;<span style="color: #d19a66;">3</span>&gt; worker_slots(<span style="color: #d19a66;">3</span>);

<span style="color: #c678dd;">void</span> <span style="color: #61afef;">worker</span>(<span style="color: #d19a66;">int</span> id) {
    std::cout &lt;&lt; <span style="color: #98c379;">"Worker "</span> &lt;&lt; id &lt;&lt; <span style="color: #98c379;">" is waiting for a slot...\n"</span>;
    
    worker_slots.acquire(); <span style="color: #5c6370;">// Chờ và chiếm một slot</span>
    
    std::cout &lt;&lt; <span style="color: #98c379;">"Worker "</span> &lt;&lt; id &lt;&lt; <span style="color: #98c379;">" has acquired a slot and is working.\n"</span>;
    std::this_thread::sleep_for(std::chrono::seconds(<span style="color: #d19a66;">2</span>)); <span style="color: #5c6370;">// Giả lập công việc</span>
    
    std::cout &lt;&lt; <span style="color: #98c379;">"Worker "</span> &lt;&lt; id &lt;&lt; <span style="color: #98c379;">" has finished and is releasing the slot.\n"</span>;
    
    worker_slots.release(); <span style="color: #5c6370;">// Giải phóng slot</span>
}

<span style="color: #d19a66;">int</span> <span style="color: #61afef;">main</span>() {
    std::vector&lt;std::thread&gt; workers;
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">10</span>; ++i) {
        workers.emplace_back(worker, i);
    }

    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">auto</span>&amp; w : workers) {
        w.join();
    }

    <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">0</span>;
}
</code></pre>
                    </div>
					
					<div class="explanation-panel hidden mt-4 border-l-4 border-sky-500 bg-sky-50 p-4 rounded-r-lg text-gray-700">
                        <h6 class="font-bold text-lg mb-2 text-sky-800">Giải thích hoạt động của Semaphore</h6>
                        <p class="mb-2">Đoạn code này minh họa cách dùng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::counting_semaphore</code> để giới hạn số lượng luồng truy cập tài nguyên cùng lúc. Tưởng tượng bạn có một nhà bếp với chỉ 3 cái bếp, nhưng lại có 10 đầu bếp muốn nấu ăn. Semaphore chính là người quản lý 3 cái bếp đó.</p>
                        <p class="font-semibold">Luồng hoạt động của chương trình:</p>
                        <ol class="list-decimal list-inside space-y-2 mt-2">
                            <li><strong>Khởi tạo:</strong> Một semaphore tên là <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">worker_slots</code> được tạo với bộ đếm ban đầu là 3.</li>
                            <li><strong>Tạo Luồng:</strong> 10 luồng được tạo ra, mỗi luồng bắt đầu chạy hàm <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">worker</code>.</li>
                            <li><strong>Cuộc đua giành slot:</strong>
                                <ul class="list-disc list-inside ml-4">
                                    <li>3 luồng đầu tiên gọi <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">acquire()</code> sẽ thành công, làm giảm bộ đếm xuống 0 và bắt đầu "làm việc".</li>
                                    <li>7 luồng còn lại khi gọi <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">acquire()</code> sẽ thấy bộ đếm là 0 và bị block (dừng lại để chờ).</li>
                                </ul>
                            </li>
                            <li><strong>Giải phóng và Tiếp tục:</strong> Sau 2 giây, một luồng làm việc xong sẽ gọi <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">release()</code>, làm tăng bộ đếm lên 1. Ngay lập tức, một trong các luồng đang chờ sẽ được đánh thức, lấy slot đó và bắt đầu chạy.</li>
                            <li><strong>Lặp lại:</strong> Quá trình này tiếp tục cho đến khi tất cả các luồng đều hoàn thành. Điều này đảm bảo không bao giờ có quá 3 luồng "làm việc" cùng một lúc. </li>
                        </ol>
                    </div>
				</div>	

			</div>
				
			<div class="border-t pt-8 mt-8">
				<h4 class="font-bold text-2xl mb-3 text-cyan-700">5.3. Condition Variable (Biến điều kiện)</h4>
				<p class="mb-4"><strong>Biến điều kiện</strong> là một cơ chế đồng bộ hóa phức tạp hơn, cho phép các luồng chờ đợi (wait) một cách hiệu quả cho đến khi một điều kiện hoặc sự kiện cụ thể nào đó xảy ra. Chúng không phải là một cơ chế khóa, mà là một cơ chế <strong>báo hiệu (signaling)</strong>. Do đó, chúng luôn luôn phải được sử dụng cùng với một mutex để tránh race condition trên chính điều kiện đang được kiểm tra.</p>
				
				<p class="mb-4"><strong>Cách hoạt động</strong>: Luồng làm việc của biến điều kiện thường theo một chu trình ba bước: chờ - thay đổi - báo hiệu.</p>
				
				<ol class="list-decimal list-inside space-y-1 text-gray-700 mb-4">
					<strong><li>Luồng chờ (Waiting Thread)</strong>:
						<ul class="list-disc list-inside ml-6 mt-1 space-y-1">
							<li>Khóa mutex (sử dụng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::unique_lock)</code>.</li>
							<li>Kiểm tra điều kiện trong một vòng lặp <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">while</code>. Việc dùng vòng lặp là bắt buộc để xử lý "spurious wakeups" (tình trạng luồng bị đánh thức một cách giả mạo mà không có thông báo).</li>
							<li>Nếu điều kiện sai, luồng gọi <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">wait()</code> trên biến điều kiện. Lệnh <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">wait()</code> sẽ làm ba việc một cách nguyên tử:</li>
							<ol type="a" class="list-[lower-alpha] list-inside ml-6 mt-1 space-y-1">
								<li>Tự động giải phóng mutex.</li>
								<li>Đưa luồng vào trạng thái chờ (blocked).</li>
								<li>Khi được đánh thức, nó sẽ cố gắng khóa lại mutex trước khi thoát khỏi hàm <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">wait()</code>.</li>
							</ol>
						</ul>
					</li>
					<strong><li>Luồng báo hiệu (Notifying Thread)</strong>:
						<ul class="list-disc list-inside ml-6 mt-1 space-y-1">
							<li>Khóa cùng một mutex.</li>
							<li>Thay đổi trạng thái chia sẻ để làm cho điều kiện trở thành đúng.</li>
							<li>Gọi <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">notify_one()</code>  (đánh thức một luồng đang chờ) hoặc <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">notify_all()</code> (đánh thức tất cả các luồng đang chờ) trên cùng một biến điều kiện.</li>
							<li>Giải phóng mutex.</li>
						</ul>	
					</li>
				</ol>
				
				<div class="code-container">
					<h5 class="font-semibold text-lg mb-2 text-cyan-700">Ví dụ 3: Bài toán Nhà sản xuất - Người tiêu dùng</h5>
					<p class="mb-4">Một hoặc nhiều luồng "Nhà sản xuất" tạo ra các mục dữ liệu và đặt chúng vào một hàng đợi (buffer) chung có kích thước giới hạn. Một hoặc nhiều luồng "Người tiêu dùng" lấy các mục dữ liệu từ hàng đợi đó để xử lý.</p>
				
					<p><strong>Vấn đề cần giải quyết</strong>:
						<ul class="list-disc list-inside space-y-1 text-gray-700 mb-4">
							<li>"Người tiêu dùng" không được cố gắng lấy dữ liệu khi buffer rỗng (phải chờ).</li>
							<li>"Nhà sản xuất" không được cố gắng thêm dữ liệu khi buffer đã đầy (phải chờ).</li>
						</ul>
					</p>
					<p class="mb-4"><strong>Giải pháp</strong>: Sử dụng một mutex để bảo vệ buffer và hai biến điều kiện: <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">cv_not_full</code> để báo hiệu cho Producer rằng buffer đã có chỗ trống và <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">cv_not_empty </code>để báo hiệu cho Consumer rằng buffer đã có dữ liệu.</p>

					<div class="code-block" data-example-id="producer-consumer">
<pre><code><span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;iostream&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;thread&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;queue&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;mutex&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;condition_variable&gt;</span>

std::queue&lt;<span style="color: #d19a66;">int</span>&gt; buffer;
std::mutex mtx;
std::condition_variable cv;
<span style="color: #c678dd;">const unsigned int</span> MAX_BUFFER_SIZE = <span style="color: #d19a66;">5</span>;

<span style="color: #c678dd;">void</span> <span style="color: #61afef;">producer</span>(<span style="color: #d19a66;">int</span> id) {
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">10</span>; ++i) {
        std::unique_lock&lt;std::mutex&gt; lock(mtx);
        cv.wait(lock, []{ <span style="color: #c678dd;">return</span> buffer.size() &lt; MAX_BUFFER_SIZE; });
        
        buffer.push(i);
        std::cout &lt;&lt; <span style="color: #98c379;">"Producer "</span> &lt;&lt; id &lt;&lt; <span style="color: #98c379;">" produced item "</span> &lt;&lt; i &lt;&lt; <span style="color: #98c379;">".\n"</span>;
        
        lock.unlock();
        cv.notify_one();
    }
}

<span style="color: #c678dd;">void</span> <span style="color: #61afef;">consumer</span>(<span style="color: #d19a66;">int</span> id) {
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">10</span>; ++i) {
        std::unique_lock&lt;std::mutex&gt; lock(mtx);
        cv.wait(lock, []{ <span style="color: #c678dd;">return</span> !buffer.empty(); });
        
        <span style="color: #d19a66;">int</span> item = buffer.front();
        buffer.pop();
        std::cout &lt;&lt; <span style="color: #98c379;">"Consumer "</span> &lt;&lt; id &lt;&lt; <span style="color: #98c379;">" consumed item "</span> &lt;&lt; item &lt;&lt; <span style="color: #98c379;">".\n"</span>;
        
        lock.unlock();
        cv.notify_one();
    }
}

<span style="color: #d19a66;">int</span> <span style="color: #61afef;">main</span>() {
    std::thread p1(producer, 1);
    std::thread c1(consumer, 1);
    p1.join();
    c1.join();
    <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">0</span>;
}
</code></pre>
					</div>
				
					<div class="explanation-panel hidden mt-4 border-l-4 border-sky-500 bg-sky-50 p-4 rounded-r-lg text-gray-700">
						<h6 class="font-bold text-lg mb-2 text-sky-800">Giải thích</h6>
							<p class="mb-2">Đoạn code này là một ví dụ kinh điển về "Bài toán Nhà sản xuất - Người tiêu dùng" (Producer-Consumer Problem), một vấn đề cốt lõi trong lập trình đồng thời. Nó giải quyết kịch bản nơi một hoặc nhiều luồng (Producer) tạo ra dữ liệu và đưa vào một bộ đệm chung, trong khi một hoặc nhiều luồng khác (Consumer) lấy dữ liệu ra khỏi bộ đệm đó để xử lý. Vấn đề là phải làm sao để Producer không thêm dữ liệu khi bộ đệm đã đầy và Consumer không cố lấy dữ liệu khi bộ đệm đang rỗng, tất cả phải diễn ra một cách an toàn và hiệu quả.</p>
							<p class="mb-2">Công cụ chính được sử dụng ở đây là <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::condition_variable</code>, hoạt động như một hệ thống tín hiệu cho phép các luồng chờ đợi một điều kiện nào đó xảy ra mà không cần liên tục kiểm tra (busy-waiting), giúp tiết kiệm tài nguyên CPU.</p>
							<p class="font-semibold mt-4">Tưởng tượng một dây chuyền trong tiệm bánh:</p>
							<ul class="list-disc list-inside space-y-1 mt-2">
								<li><strong>Producer (Người sản xuất):</strong> là người thợ làm bánh.</li>
								<li><strong>Consumer (Người tiêu dùng):</strong> là người đóng gói bánh.</li>
								<li><strong>Buffer (Bộ đệm):</strong> là băng chuyền đặt bánh.</li>
								<li><strong>Mutex:</strong> là quy tắc "chỉ một người được chạm vào băng chuyền tại một thời điểm".</li>
								<li><strong>Condition Variable:</strong> là hệ thống liên lạc. Người làm bánh sẽ hét lên "Có bánh mới!" khi đặt bánh lên, và người đóng gói sẽ hét lên "Lấy bánh rồi, có chỗ trống!" khi lấy bánh đi.</li>
							</ul>
							<p class="font-semibold mt-4">Luồng hoạt động chính:</p>
							<ol class="list-decimal list-inside space-y-2 mt-2">
								<li>Producer khóa mutex, kiểm tra buffer chưa đầy, nó liền đặt bánh vào, sau đó mở khóa và thông báo (<code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">notify_one()</code>).</li>
								<li>Consumer lấy được khóa, kiểm tra buffer không rỗng, nó liền lấy bánh ra, sau đó mở khóa và thông báo.</li>
								<li>Khi buffer đầy, Producer sẽ thấy điều kiện sai, nó tự động nhả khóa mutex và "đi ngủ" (<code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">cv.wait</code>).</li>
								<li>Lúc này chỉ có Consumer có thể chạy. Sau khi lấy bánh, nó gọi <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">notify_one()</code> để "đánh thức" Producer đang ngủ dậy.</li>
								<li>Producer thức dậy, khóa lại mutex, kiểm tra lại điều kiện (lần này là đúng) và tiếp tục công việc.</li>
							</ol>
							<p class="mt-2">Quá trình này cứ thế tiếp diễn, tạo ra một sự phối hợp nhịp nhàng và hiệu quả giữa hai luồng.</p>
					</div>
				</div>
			</div>

			<div class="border-t pt-8 mt-8">
				<h4 class="font-bold text-2xl mb-3 text-cyan-700">5.4. Atomic Operations (Thao tác Nguyên tử)</h4>
				<p class="mb-4"><strong>Thao tác nguyên tử</strong> là các thao tác được đảm bảo thực hiện như một đơn vị duy nhất, không thể bị chia cắt hay xen ngang bởi các luồng khác. Chúng thường được thực thi trực tiếp bởi các chỉ thị đặc biệt của phần cứng (CPU instructions), do đó cực kỳ hiệu quả và không gây ra tình trạng chặn luồng như mutex. Chúng là nền tảng của <strong>lập trình không khóa (lock-free programming)</strong>.</p>
				<p class="mb-4"><strong>Mục đích</strong>: Các thao tác nguyên tử được sử dụng cho các tác vụ đồng bộ hóa rất đơn giản và thường xuyên, chẳng hạn như tăng một biến đếm, đọc/ghi một cờ trạng thái (flag), hay thực hiện so sánh và trao đổi (compare-and-swap). Việc sử dụng chúng giúp tránh được chi phí quản lý (overhead) của mutex trong những trường hợp đơn giản này.</p>
				<p><strong>Hướng dẫn trong C++:</strong>
				<p class="mb-4">Thư viện chuẩn C++ cung cấp lớp template <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::atomic&lt;T&gt;</code> trong header <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">&lt;atomic&gt;</code>. Nó có thể được sử dụng với hầu hết các kiểu dữ liệu cơ bản (như bool, int, long long, con trỏ).</p>
				
				<div class="code-container">				
					<h5 class="font-semibold text-lg mb-2 text-cyan-700">Ví dụ 4: Giải pháp thay thế Mutex hiệu năng cao</h5>
					<h5 class="font-semibold text-lg mb-2">Giải pháp thay thế Mutex hiệu năng cao</h5>
					<p class="mb-4 text-gray-700">Mã nguồn dưới đây viết lại ví dụ biến đếm bị race condition bằng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::atomic</code>. Kết quả không chỉ ngắn gọn hơn mà còn có hiệu năng cao hơn đáng kể so với phiên bản dùng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">mutex</code>, vì nó tránh được việc chặn và chuyển đổi ngữ cảnh của các luồng.</p>
					<div class="code-block" data-example-id="atomic-counter">
<pre><code><span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;iostream&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;thread&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;vector&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;atomic&gt;</span>

<span style="color: #5c6370;">// Sử dụng std::atomic để đảm bảo các thao tác là nguyên tử</span>
std::atomic&lt;<span style="color: #d19a66;">long long</span>&gt; atomic_counter(<span style="color: #d19a66;">0</span>);

<span style="color: #c678dd;">void</span> <span style="color: #61afef;">increment_atomic</span>() {
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">100000</span>; ++i) {
        <span style="color: #5c6370;">// fetch_add là một thao tác RMW (Read-Modify-Write) nguyên tử</span>
        <span style="color: #5c6370;">// Tương đương với atomic_counter++</span>
        atomic_counter.fetch_add(<span style="color: #d19a66;">1</span>, std::memory_order_relaxed);
    }
}

<span style="color: #d19a66;">int</span> <span style="color: #61afef;">main</span>() {
    std::vector&lt;std::thread&gt; threads;
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">10</span>; ++i) {
        threads.push_back(std::thread(increment_atomic));
    }

    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">auto</span>&amp; th : threads) {
        th.join();
    }

    <span style="color: #5c6370;">// load() là một thao tác đọc nguyên tử</span>
    std::cout &lt;&lt; <span style="color: #98c379;">"Final counter: "</span> &lt;&lt; atomic_counter.load() &lt;&lt; std::endl; <span style="color: #5c6370;">// Kết quả luôn là 1,000,000</span>
    <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">0</span>;
}
</code></pre>
				</div>
						<div class="explanation-panel hidden mt-4 border-l-4 border-sky-500 bg-sky-50 p-4 rounded-r-lg text-gray-700">
							<h6 class="font-bold text-lg mb-2 text-sky-800">Giải thích</h6>
							<p class="mb-2">Đoạn code này trình bày một cách khác để giải quyết vấn đề Race Condition mà không cần dùng đến mutex, thay vào đó nó sử dụng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::atomic</code>. Một thao tác được gọi là "nguyên tử" khi nó được đảm bảo sẽ thực thi hoàn chỉnh mà không bị bất kỳ luồng nào khác xen ngang. Hãy tưởng tượng nó như một hành động "tất cả hoặc không gì cả", không có trạng thái lưng chừng.</p>
							<p class="mb-2">So với việc dùng mutex để "khóa" cả một khu vực, <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::atomic</code> hoạt động ở cấp độ thấp hơn, thường được dịch trực tiếp thành các chỉ thị đặc biệt của CPU, giúp nó trở nên cực kỳ hiệu quả cho các thao tác đơn giản.</p>
							<p class="mt-4"><strong>Khi nào nên dùng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::atomic</code>?</strong></p>
							<p class="mb-2"><code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::atomic</code> là lựa chọn lý tưởng khi bạn chỉ cần thực hiện các thao tác đơn giản (tăng, giảm, gán, so sánh-và-trao-đổi) trên một biến duy nhất (như biến đếm, cờ trạng thái). Nó mang lại sự an toàn mà không có chi phí hiệu năng lớn như mutex. </p>
							<p class="mt-2"><strong>Khi nào nên dùng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::mutex</code>?</strong></p>
							<p>Khi bạn cần bảo vệ một vùng mã thực hiện nhiều thao tác trên một hoặc nhiều biến được chia sẻ. Ví dụ, bạn cần đọc một biến, tính toán phức tạp, rồi cập nhật hai biến khác dựa trên kết quả đó. Toàn bộ chuỗi hành động này cần được bảo vệ như một khối duy nhất, và đó là lúc mutex phát huy tác dụng. </p>
						</div>
                </div>
			</div>
		</section>
        
        <section id="part6" class="py-12 bg-white rounded-lg shadow-xl my-12 p-6 md:p-8">
			<h3 class="text-3xl font-bold text-center mb-2">6. Thực hành lập trình đa luồng trong C++</h3>
			<p class="text-center max-w-3xl mx-auto text-gray-600 mb-12">Thực hiện bài toán nhân ma trận với kích thước lớn để so sánh độ hiệu quả của kỹ thuật lập trình đa luồng so với lập trình thông thường</p>

			<div class="border-t pt-8 mt-8 text-justify">
				<h4 class="font-bold text-2xl mb-3 text-cyan-700">6.1. Giới thiệu Thư viện <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">&lt;thread&gt;</code> của C++11</h4>
				<p class="mb-4">Kể từ phiên bản C++11, thư viện chuẩn đã cung cấp sự hỗ trợ mạnh mẽ cho lập trình đa luồng thông qua header <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">&lt;thread&gt;</code>.</p>
				
				<h5 class="font-semibold text-lg mb-2 text-cyan-700">Tạo một luồng mới:</h5>
				<p class="mb-4 text-gray-700">Để tạo một luồng mới, ta chỉ cần khởi tạo một đối tượng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::thread</code> và truyền vào cho nó một hàm (hoặc một đối tượng có thể gọi được - callable object) làm điểm bắt đầu thực thi của luồng đó.</p>
				<div class="code-block mb-6">
<pre><code><span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;iostream&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;thread&gt;</span>

<span style="color: #c678dd;">void</span> <span style="color: #61afef;">task_function</span>() {
    std::cout &lt;&lt; <span style="color: #98c379;">"Hello from a new thread!\n"</span>;
}

<span style="color: #d19a66;">int</span> <span style="color: #61afef;">main</span>() {
    <span style="color: #5c6370;">// Tạo một luồng mới và bắt đầu thực thi task_function</span>
    std::thread my_thread(task_function);

    <span style="color: #5c6370;">//... (luồng main có thể làm việc khác ở đây)</span>

    <span style="color: #5c6370;">// Chờ luồng con kết thúc</span>
    my_thread.join();

    std::cout &lt;&lt; <span style="color: #98c379;">"Thread has finished.\n"</span>;
    <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">0</span>;
}
</code></pre>
				</div>

				<h5 class="font-semibold text-lg mb-2 text-cyan-700"><code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">join()</code> và <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">detach()</code></h5>
				<p class="mb-4 text-gray-700">Mỗi đối tượng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::thread</code> phải được xử lý trước khi nó bị hủy (ví dụ, khi ra khỏi scope). Có hai cách để làm điều này:</p>
				<ul class="list-disc list-inside space-y-2 text-gray-700">
					<li><code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">join()</code>: Luồng gọi (ví dụ: luồng main) sẽ bị chặn và chờ cho đến khi luồng được <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">join</code> hoàn thành việc thực thi của nó. Đây là cách phổ biến nhất để đồng bộ hóa và đảm bảo rằng mọi công việc của luồng con đã được hoàn tất trước khi chương trình chính tiếp tục hoặc kết thúc.</li>
					<li><code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">detach()</code>: Tách luồng con ra khỏi đối tượng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::thread</code>. Sau khi <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">detach</code>, luồng con sẽ tiếp tục chạy độc lập trong nền. Luồng con sẽ tự động được dọn dẹp tài nguyên bởi hệ thống khi nó thực thi xong. Việc sử dụng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">detach</code> cần cẩn thận, vì luồng chính sẽ mất khả năng giao tiếp hoặc chờ đợi luồng con.</li>
				</ul>
				chương trình sẽ bị chấm dứt (terminate) nếu một đối tượng <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">std::thread</code> bị hủy mà chưa được <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">join</code> hoặc <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">detach</code>.</p>
			</div>

			<div class="border-t pt-8 mt-8">
				<h4 class="font-bold text-2xl mb-3 text-cyan-700">6.2. Thực hành nhân hai ma trận kích thước lớn</h4>
				<div class="code-container">
					<h5 class="font-semibold text-lg mt-4 mb-4 text-cyan-700">Tệp Header Dùng chung: <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">matrix_utils.h</code></h5>
					<p class="mb-4">Để mã nguồn sạch sẽ và dễ quản lý, tất cả ba phiên bản nhân ma trận đều sử dụng một tệp header chung chứa <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">struct Matrix</code> và các hàm đọc/ghi file.</p>
					<div class="code-block" data-example-id="matrix-utils">
<pre><code><span style="color: #c678dd;">#ifndef</span> <span style="color: #e5c07b;">MATRIX_UTILS_H</span>
<span style="color: #c678dd;">#define</span> <span style="color: #e5c07b;">MATRIX_UTILS_H</span>

<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;iostream&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;vector&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;string&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;fstream&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;stdexcept&gt;</span> <span style="color: #5c6370;">// Để dùng std::runtime_error</span>

<span style="color: #5c6370;">// Sử dụng struct để đóng gói dữ liệu của ma trận một cách gọn gàng</span>
<span style="color: #c678dd;">struct</span> <span style="color: #e5c07b;">Matrix</span> {
    <span style="color: #d19a66;">int</span> rows = <span style="color: #d19a66;">0</span>;
    <span style="color: #d19a66;">int</span> cols = <span style="color: #d19a66;">0</span>;
    std::vector&lt;std::vector&lt;<span style="color: #d19a66;">int</span>&gt;&gt; data;
};

<span style="color: #5c6370;">// Hàm đọc ma trận từ file, trả về một đối tượng Matrix</span>
<span style="color: #5c6370;">// Ném ra ngoại lệ (exception) nếu có lỗi thay vì thoát chương trình</span>
<span style="color: #c678dd;">inline</span> Matrix <span style="color: #61afef;">read_matrix_from_file</span>(<span style="color: #c678dd;">const</span> std::string&amp; filename) {
    std::ifstream file(filename);
    <span style="color: #c678dd;">if</span> (!file.is_open()) {
        <span style="color: #c678dd;">throw</span> std::runtime_error(<span style="color: #98c379;">"Error: Could not open file "</span> + filename);
    }

    Matrix mat;
    file &gt;&gt; mat.rows &gt;&gt; mat.cols;
    <span style="color: #c678dd;">if</span> (mat.rows &lt;= <span style="color: #d19a66;">0</span> || mat.cols &lt;= <span style="color: #d19a66;">0</span>) {
        <span style="color: #c678dd;">throw</span> std::runtime_error(<span style="color: #98c379;">"Invalid matrix dimensions in file: "</span> + filename);
    }

    mat.data.assign(mat.rows, std::vector&lt;<span style="color: #d19a66;">int</span>&gt;(mat.cols));
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; mat.rows; ++i) {
        <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> j = <span style="color: #d19a66;">0</span>; j &lt; mat.cols; ++j) {
            <span style="color: #c678dd;">if</span> (!(file &gt;&gt; mat.data[i][j])) {
                 <span style="color: #c678dd;">throw</span> std::runtime_error(<span style="color: #98c379;">"Error reading data from file: "</span> + filename);
            }
        }
    }
    <span style="color: #c678dd;">return</span> mat;
}

<span style="color: #5c6370;">// Hàm ghi ma trận ra file</span>
<span style="color: #c678dd;">inline</span> <span style="color: #c678dd;">void</span> <span style="color: #61afef;">write_matrix_to_file</span>(<span style="color: #c678dd;">const</span> Matrix&amp; mat, <span style="color: #c678dd;">const</span> std::string&amp; filename) {
    std::ofstream file(filename);
    <span style="color: #c678dd;">if</span> (!file.is_open()) {
        <span style="color: #c678dd;">throw</span> std::runtime_error(<span style="color: #98c379;">"Error: Could not open file for writing "</span> + filename);
    }

    file &lt;&lt; mat.rows &lt;&lt; <span style="color: #98c379;">" "</span> &lt;&lt; mat.cols &lt;&lt; <span style="color: #98c379;">"\n"</span>;
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; mat.rows; ++i) {
        <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> j = <span style="color: #d19a66;">0</span>; j &lt; mat.cols; ++j) {
            file &lt;&lt; mat.data[i][j] &lt;&lt; (j == mat.cols - <span style="color: #d19a66;">1</span> ? <span style="color: #98c379;">""</span> : <span style="color: #98c379;">" "</span>);
        }
        file &lt;&lt; <span style="color: #98c379;">"\n"</span>;
    }
}

<span style="color: #c678dd;">#endif</span> <span style="color: #5c6370;">// MATRIX_UTILS_H</span>
</code></pre>
					</div>
					<div class="explanation-panel hidden mt-4 border-l-4 border-sky-500 bg-sky-50 p-4 rounded-r-lg text-gray-700">
						<h6 class="font-bold text-lg mb-2 text-sky-800">Giải thích</h6>
						<p class="mb-2">Tệp <code>matrix_utils.h</code> này là một ví dụ điển hình về một mô-đun tiện ích trong lập trình. Nó cung cấp các công cụ có thể tái sử dụng để thao tác với ma trận, giúp cho mã nguồn chính (ví dụ: tệp <code>main.cpp</code>) trở nên gọn gàng và tập trung vào logic nghiệp vụ hơn là các chi tiết đọc/ghi file.</p>
						
						<p class="font-semibold mt-4">1. Các Thành phần Chính</p>
						<ul class="list-disc list-inside space-y-2 mt-2">
							<li><strong><code>Matrix</code>:</strong> Việc sử dụng <code>struct</code> để nhóm số hàng (rows), số cột (cols), và dữ liệu (data) lại với nhau là một thực hành lập trình rất tốt. Nó tạo ra một kiểu dữ liệu mới, giúp mã nguồn dễ đọc và dễ quản lý hơn. Thay vì phải truyền ba biến riêng lẻ cho các hàm, bạn chỉ cần truyền một đối tượng <code>Matrix</code>.</li>
							<li><strong><code>read_matrix_from_file</code>:</strong> Hàm này đảm nhận toàn bộ quá trình phức tạp của việc đọc file: mở file, kiểm tra lỗi, đọc kích thước, cấp phát bộ nhớ, và đọc từng phần tử. Nó được thiết kế để rất mạnh mẽ (robust) nhờ việc kiểm tra lỗi ở mọi bước.</li>
							<li><strong><code>write_matrix_to_file</code>:</strong> Tương tự, hàm này đóng gói logic ghi ma trận ra file theo một định dạng chuẩn (dòng đầu là kích thước, các dòng sau là dữ liệu), đảm bảo rằng tệp được tạo ra bởi hàm này có thể được đọc lại một cách chính xác bởi <code>read_matrix_from_file</code>.</li>
						</ul>

						<p class="font-semibold mt-4">2. Cách Xử lý Lỗi Bằng Ngoại lệ (Exceptions)</p>
						<p class="mb-2">Một trong những điểm thiết kế quan trọng nhất ở đây là việc sử dụng <code>throw std::runtime_error</code>. Đây là một cách xử lý lỗi hiện đại và linh hoạt.</p>
						<ul class="list-disc list-inside space-y-1 mt-2">
							<li><strong>Tại sao lại dùng <code>throw</code>?:</strong> Thay vì in ra một thông báo lỗi và gọi <code>exit(1)</code> (làm chương trình dừng ngay lập tức), việc "ném" một ngoại lệ cho phép chương trình gọi hàm quyết định cách xử lý. Ví dụ, trong <code>main.cpp</code>, bạn có thể đặt lời gọi hàm <code>read_matrix_from_file</code> trong một khối <code>try...catch</code> để:
								<ul class="list-disc list-inside ml-4 mt-1">
									<li>Bắt lỗi và thông báo cho người dùng một cách thân thiện.</li>
									<li>Cố gắng đọc một tệp dự phòng.</li>
									<li>Ghi lỗi vào một tệp log.</li>
								</ul>
							</li>
						</ul>

						<p class="font-semibold mt-4">3. Các Điểm Đáng Chú Ý về Hiệu năng và Cú pháp</p>
						<ul class="list-disc list-inside space-y-2 mt-2">
							<li><strong>Truyền bằng Tham chiếu Hằng (<code>const &</code>):</strong> Khi truyền các đối tượng lớn như <code>std::string</code> hay <code>Matrix</code> vào hàm, việc sử dụng tham chiếu (<code>&</code>) sẽ ngăn việc tạo ra một bản sao hoàn chỉnh của đối tượng, giúp tiết kiệm bộ nhớ và thời gian xử lý. Thêm <code>const</code> để đảm bảo rằng hàm sẽ không vô tình thay đổi giá trị của đối tượng gốc.</li>
							<li><strong>Toán tử ba ngôi (<code>? :</code>):</strong> Cú pháp <code>(condition ? value_if_true : value_if_false)</code> trong hàm <code>write_matrix_to_file</code> là một cách viết ngắn gọn và thanh lịch cho một câu lệnh <code>if...else</code> đơn giản, giúp mã nguồn gọn hơn khi xử lý định dạng đầu ra.</li>
						</ul>
					</div>
				</div>
				
				
				<div class="code-container">
					<h5 class="font-semibold text-lg mt-8 text-cyan-700"><strong>Phiên bản 1</strong>: Nhân ma trận Tuần tự</h5>
					<p class="mb-4">Đây là thuật toán cơ bản, thực hiện toàn bộ phép tính trên một luồng duy nhất.</p>
					<div class="code-block" data-example-id="sequential-mult">
<pre><code><span style="color: #5c6370;">// sequential_multiplication.cpp</span>
<span style="color: #5c6370;">// Mô tả: Nhân ma trận một cách tuần tự sử dụng một luồng duy nhất.</span>
<span style="color: #5c6370;">// Dùng làm cơ sở để so sánh hiệu năng.</span>

<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">"matrix_utils.h"</span> <span style="color: #5c6370;">// Sử dụng các hàm và struct chung</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;chrono&gt;</span>

<span style="color: #5c6370;">// Hàm nhân ma trận tuần tự</span>
Matrix <span style="color: #61afef;">multiply_sequentially</span>(<span style="color: #c678dd;">const</span> Matrix&amp; A, <span style="color: #c678dd;">const</span> Matrix&amp; B) {
    Matrix C;
    C.rows = A.rows;
    C.cols = B.cols;
    C.data.assign(C.rows, std::vector&lt;<span style="color: #d19a66;">int</span>&gt;(C.cols, <span style="color: #d19a66;">0</span>));

    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; A.rows; ++i) {
        <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> j = <span style="color: #d19a66;">0</span>; j &lt; B.cols; ++j) {
            <span style="color: #d19a66;">int</span> sum = <span style="color: #d19a66;">0</span>;
            <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> k = <span style="color: #d19a66;">0</span>; k &lt; A.cols; ++k) {
                sum += A.data[i][k] * B.data[k][j];
            }
            C.data[i][j] = sum;
        }
    }
    <span style="color: #c678dd;">return</span> C;
}

<span style="color: #d19a66;">int</span> <span style="color: #61afef;">main</span>() {
    <span style="color: #c678dd;">try</span> {
        Matrix A = read_matrix_from_file(<span style="color: #98c379;">"A.txt"</span>);
        Matrix B = read_matrix_from_file(<span style="color: #98c379;">"B.txt"</span>);

        <span style="color: #c678dd;">if</span> (A.cols != B.rows) {
            <span style="color: #c678dd;">throw</span> std::invalid_argument(<span style="color: #98c379;">"Error: Incompatible matrix dimensions for multiplication."</span>);
        }

        <span style="color: #d19a66;">auto</span> start_time = std::chrono::high_resolution_clock::now();
        Matrix C = multiply_sequentially(A, B);
        <span style="color: #d19a66;">auto</span> end_time = std::chrono::high_resolution_clock::now();

        <span style="color: #d19a66;">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_time - start_time);
        std::cout &lt;&lt; <span style="color: #98c379;">"Time taken for sequential multiplication: "</span> &lt;&lt; duration.count() &lt;&lt; <span style="color: #98c379;">" milliseconds\n"</span>;

        write_matrix_to_file(C, <span style="color: #98c379;">"C_sequential.txt"</span>);
        std::cout &lt;&lt; <span style="color: #98c379;">"Result saved to C_sequential.txt\n"</span>;

    } <span style="color: #c678dd;">catch</span> (<span style="color: #c678dd;">const</span> std::exception&amp; e) {
        std::cerr &lt;&lt; <span style="color: #98c379;">"An error occurred: "</span> &lt;&lt; e.what() &lt;&lt; std::endl;
        <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">1</span>;
    }
    <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">0</span>;
}
</code></pre>
					</div>
					<div class="explanation-panel hidden mt-4 border-l-4 border-sky-500 bg-sky-50 p-4 rounded-r-lg text-gray-700">
						<h6 class="font-bold text-lg mb-2 text-sky-800">Giải thích sâu hơn</h6>
						<p class="mb-2">Chương trình này thực hiện một nhiệm vụ cơ bản trong đại số tuyến tính: nhân hai ma trận. Tuy nhiên, nó được viết với mục đích rõ ràng là tạo ra một chuẩn cơ sở (baseline) về hiệu năng.</p>
						
						<p class="font-semibold mt-4">1. Thuật toán nhân ma trận</p>
						<p class="mb-2">Hàm <code>multiply_sequentially</code> sử dụng thuật toán nhân ma trận kinh điển mà bạn thường học ở trường. Để tính giá trị của một phần tử tại vị trí (i, j) trong ma trận kết quả C, thuật toán sẽ:</p>
						<ul class="list-disc list-inside space-y-1 mt-2 ml-4">
							<li>Lấy hàng thứ <strong>i</strong> của ma trận A.</li>
							<li>Lấy cột thứ <strong>j</strong> của ma trận B.</li>
							<li>Thực hiện phép tích vô hướng (dot product) giữa chúng: nhân từng cặp phần tử tương ứng rồi cộng tất cả lại.</li>
						</ul>
						<p class="mt-2 mb-2">Ba vòng lặp lồng nhau mô phỏng chính xác quá trình này:</p>
						<ul class="list-disc list-inside space-y-1 mt-2 ml-4">
							<li>Vòng lặp <strong>i</strong> và <strong>j</strong> chọn vị trí C[i][j] để tính toán.</li>
							<li>Vòng lặp <strong>k</strong> thực hiện phép tích vô hướng, duyệt qua các phần tử của hàng A[i] và cột B[j].</li>
						</ul>
						<p class="mt-2">Độ phức tạp tính toán của thuật toán này là $O(n^3)$ nếu các ma trận là vuông và có kích thước $n \times n$. Điều này có nghĩa là nếu bạn tăng gấp đôi kích thước của ma trận, thời gian tính toán sẽ tăng lên khoảng $2^3 = 8$ lần. Đây là lý do tại sao việc tối ưu hóa phép nhân ma trận (ví dụ, bằng cách sử dụng đa luồng) lại rất quan trọng đối với các ma trận lớn.</p>

						<p class="font-semibold mt-4">2. Đo lường hiệu năng (Benchmarking)</p>
						<p class="mb-2">Mục đích chính của tệp này là đo thời gian thực thi. Thư viện <code>&lt;chrono&gt;</code> của C++ cung cấp một bộ công cụ mạnh mẽ và chính xác để làm việc này.</p>
						<ul class="list-disc list-inside space-y-2 mt-2">
							<li><strong><code>std::chrono::high_resolution_clock</code>:</strong> Đây là loại đồng hồ được thiết kế để cung cấp độ phân giải (tức độ chính xác) cao nhất mà hệ thống có thể hỗ trợ. Nó lý tưởng cho việc đo các khoảng thời gian ngắn như thời gian chạy của một hàm.</li>
							<li><strong><code>auto start_time = ...::now()</code>:</strong> Lấy "dấu thời gian" (timestamp) hiện tại.</li>
							<li><strong><code>duration_cast&lt;std::chrono::milliseconds&gt;</code>:</strong> Sau khi có thời gian bắt đầu và kết thúc, phép trừ <code>end_time - start_time</code> cho ra một đối tượng duration. <code>duration_cast</code> được dùng để chuyển đổi duration này sang một đơn vị dễ đọc hơn, chẳng hạn như mili giây.</li>
						</ul>
						<p class="mt-2">Kết quả đo được từ chương trình tuần tự này sẽ là thước đo để so sánh với các phiên bản song song sau này. Nếu phiên bản đa luồng chạy nhanh hơn, con số này sẽ chứng minh sự cải thiện về hiệu năng.</p>

						<p class="font-semibold mt-4">3. Xử lý Lỗi Mạnh mẽ (Robust Error Handling)</p>
						<p class="mb-2">Toàn bộ logic trong <code>main</code> được đặt trong một khối <code>try...catch</code>. Đây là một thực hành lập trình rất tốt:</p>
						<ul class="list-disc list-inside space-y-2 mt-2">
							<li><strong>Dự đoán lỗi:</strong> Chương trình dự đoán các lỗi có thể xảy ra, chẳng hạn như tệp <code>A.txt</code> hoặc <code>B.txt</code> không tồn tại, hoặc kích thước ma trận không tương thích (<code>A.cols != B.rows</code>).</li>
							<li><strong>Xử lý tập trung:</strong> Thay vì kiểm tra lỗi ở nhiều nơi, khối <code>try...catch</code> cho phép bạn xử lý tất cả các lỗi dự kiến tại một nơi duy nhất. Các hàm trong <code>matrix_utils.h</code> và cả logic trong <code>main</code> đều "ném" (throw) ngoại lệ khi có sự cố. Khối <code>catch</code> sẽ "bắt" chúng.</li>
							<li><strong>Thông báo thân thiện:</strong> Khi lỗi xảy ra, chương trình không bị sập một cách khó hiểu. Thay vào đó, nó in ra một thông báo lỗi rõ ràng cho người dùng (<code>e.what()</code>) và kết thúc một cách có kiểm soát.</li>
						</ul>
					</div>
				</div>
				
				<div class="code-container">
					<h5 class="font-semibold text-lg mt-8 text-cyan-700"><strong>Phiên bản 2</strong>: Đa luồng Cơ bản</h5>
					<p class="mb-4">Công việc được chia cho nhiều luồng để tính toán.</p>
					<div class="code-block" data-example-id="standard-mult">
<pre><code><span style="color: #5c6370;">// multithread_standard.cpp</span>
<span style="color: #5c6370;">// Mô tả: Nhân ma trận song song sử dụng đa luồng.</span>
<span style="color: #5c6370;">// Phiên bản này minh họa cách chia việc cơ bản nhưng chưa tối ưu truy cập bộ nhớ.</span>

<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">"matrix_utils.h"</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;chrono&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;thread&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;functional&gt;</span> <span style="color: #5c6370;">// Dùng cho std::ref, std::cref</span>

<span style="color: #5c6370;">// Hàm công việc cho mỗi luồng (phiên bản chưa tối ưu)</span>
<span style="color: #c678dd;">void</span> <span style="color: #61afef;">standard_worker_task</span>(<span style="color: #c678dd;">const</span> Matrix&amp; A, <span style="color: #c678dd;">const</span> Matrix&amp; B, Matrix&amp; C, <span style="color: #d19a66;">int</span> start_row, <span style="color: #d19a66;">int</span> end_row) {
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = start_row; i &lt; end_row; ++i) {
        <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> j = <span style="color: #d19a66;">0</span>; j &lt; B.cols; ++j) {
            <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> k = <span style="color: #d19a66;">0</span>; k &lt; A.cols; ++k) {
                C.data[i][j] += A.data[i][k] * B.data[k][j];
            }
        }
    }
}

<span style="color: #5c6370;">// Hàm điều phối việc nhân ma trận đa luồng</span>
Matrix <span style="color: #61afef;">multiply_multithreaded</span>(<span style="color: #c678dd;">const</span> Matrix&amp; A, <span style="color: #c678dd;">const</span> Matrix&amp; B) {
    <span style="color: #d19a66;">unsigned int</span> num_threads = std::thread::hardware_concurrency();
    Matrix C;
    C.rows = A.rows;
    C.cols = B.cols;
    C.data.assign(C.rows, std::vector&lt;<span style="color: #d19a66;">int</span>&gt;(C.cols, <span style="color: #d19a66;">0</span>));
    std::vector&lt;std::thread&gt; threads;
    
    <span style="color: #d19a66;">int</span> rows_per_thread = A.rows / num_threads;

    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">unsigned int</span> i = <span style="color: #d19a66;">0</span>; i &lt; num_threads; ++i) {
        <span style="color: #d19a66;">int</span> start = i * rows_per_thread;
        <span style="color: #d19a66;">int</span> end = (i == num_threads - <span style="color: #d19a66;">1</span>) ? A.rows : start + rows_per_thread;
        threads.emplace_back(standard_worker_task, std::cref(A), std::cref(B), std::ref(C), start, end);
    }

    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">auto</span>&amp; th : threads) {
        th.join();
    }
    <span style="color: #c678dd;">return</span> C;
}

<span style="color: #d19a66;">int</span> <span style="color: #61afef;">main</span>() {
    <span style="color: #c678dd;">try</span> {
        Matrix A = read_matrix_from_file(<span style="color: #98c379;">"A.txt"</span>);
        Matrix B = read_matrix_from_file(<span style="color: #98c379;">"B.txt"</span>);

        <span style="color: #c678dd;">if</span> (A.cols != B.rows) {
            <span style="color: #c678dd;">throw</span> std::invalid_argument(<span style="color: #98c379;">"Error: Incompatible matrix dimensions."</span>);
        }

        <span style="color: #d19a66;">auto</span> start_time = std::chrono::high_resolution_clock::now();
        Matrix C = multiply_multithreaded(A, B);
        <span style="color: #d19a66;">auto</span> end_time = std::chrono::high_resolution_clock::now();

        <span style="color: #d19a66;">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_time - start_time);
        std::cout &lt;&lt; <span style="color: #98c379;">"Time taken for standard multi-threading: "</span> &lt;&lt; duration.count() &lt;&lt; <span style="color: #98c379;">" milliseconds\n"</span>;

        write_matrix_to_file(C, <span style="color: #98c379;">"C_multithread_standard.txt"</span>);
        std::cout &lt;&lt; <span style="color: #98c379;">"Result saved to C_multithread_standard.txt\n"</span>;

    } <span style="color: #c678dd;">catch</span> (<span style="color: #c678dd;">const</span> std::exception&amp; e) {
        std::cerr &lt;&lt; <span style="color: #98c379;">"An error occurred: "</span> &lt;&lt; e.what() &lt;&lt; std::endl;
        <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">1</span>;
    }
    <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">0</span>;
}
</code></pre>
					</div>
					<div class="explanation-panel hidden mt-4 border-l-4 border-sky-500 bg-sky-50 p-4 rounded-r-lg text-gray-700">
						<h6 class="font-bold text-lg mb-2 text-sky-800">Giải thích sâu hơn</h6>
						<p class="mb-2">Chương trình này là một bước tiến từ phiên bản tuần tự bằng cách áp dụng lập trình song song để tăng tốc độ tính toán. Ý tưởng cốt lõi là chia nhỏ công việc và giao cho nhiều "công nhân" (luồng) làm việc cùng một lúc.</p>

						<p class="font-semibold mt-4">1. Chiến lược song song hóa: Chia theo hàng 📋</p>
						<p class="mb-2">Chiến lược được sử dụng ở đây là phân rã dữ liệu (data decomposition). Toàn bộ công việc tính toán ma trận C được chia thành các phần độc lập. Mỗi phần là việc tính toán một tập hợp các hàng của ma trận C.</p>
						<p class="mt-2"><strong>Tại sao chia theo hàng là an toàn?</strong> Việc tính toán giá trị cho một hàng <code>C[i]</code> chỉ phụ thuộc vào hàng <code>A[i]</code> và toàn bộ ma trận B. Nó hoàn toàn độc lập với việc tính toán các hàng khác của C. Do đó, các luồng có thể ghi kết quả vào các hàng khác nhau của ma trận C mà không gây ra tình trạng tranh chấp (<code>race condition</code>). Đây là một ưu điểm lớn vì chúng ta không cần các cơ chế khóa (locking) phức tạp như <code>mutex</code>, giúp mã nguồn đơn giản và hiệu quả hơn.</p>

						<p class="font-semibold mt-4">2. Vai trò của các hàm</p>
						<p class="mb-2"><strong><code>multiply_multithreaded</code> (Hàm điều phối - Dispatcher):</strong> Hàm này đóng vai trò như một người quản lý dự án.</p>
						<ul class="list-disc list-inside space-y-2 mt-2 ml-4">
							<li><strong>Xác định nhân lực:</strong> Dùng <code>std::thread::hardware_concurrency()</code> để biết có bao nhiêu công nhân (luồng) là tối ưu.</li>
							<li><strong>Chuẩn bị công việc:</strong> Khởi tạo ma trận kết quả C.</li>
							<li><strong>Phân công:</strong> Vòng lặp <code>for</code> chia các hàng của C thành các "gói công việc" (xác định bởi <code>start_row</code> và <code>end_row</code>).</li>
							<li><strong>Tuyển dụng và giao việc:</strong> Tạo ra các đối tượng <code>std::thread</code>, mỗi đối tượng được giao cho một hàm <code>standard_worker_task</code> cùng với "gói công việc" tương ứng.</li>
							<li><strong>Chờ đợi:</strong> Dùng <code>join()</code> để đảm bảo người quản lý không "báo cáo hoàn thành" dự án trước khi tất cả công nhân làm xong việc.</li>
						</ul>
						<p class="mt-2 mb-2"><strong><code>standard_worker_task</code> (Hàm công nhân - Worker):</strong> Đây là hàm mà mỗi luồng sẽ thực thi. Nó nhận phần việc của mình (một khoảng các hàng) và chỉ tập trung làm đúng phần việc đó. Logic tính toán bên trong nó giống hệt như thuật toán tuần tự, nhưng phạm vi đã được thu hẹp lại.</p>

						<p class="font-semibold mt-4">3. <code>std::ref</code> và <code>std::cref</code> - Kỹ thuật quan trọng khi làm việc với luồng</p>
						<p class="mb-2">Theo mặc định, khi bạn truyền tham số để khởi tạo một <code>std::thread</code>, các tham số đó sẽ được sao chép. Nếu chúng ta viết <code>std::thread(..., A, B, C, ...)</code>:</p>
						<ul class="list-disc list-inside space-y-1 mt-2 ml-4">
							<li>Các ma trận khổng lồ A, B, và C sẽ được sao chép toàn bộ cho mỗi luồng. Điều này cực kỳ tốn kém về bộ nhớ và thời gian.</li>
							<li>Quan trọng hơn, mỗi luồng sẽ làm việc trên một bản sao của C, và kết quả sẽ không được ghi lại vào ma trận C gốc trong hàm <code>multiply_multithreaded</code>.</li>
						</ul>
						<p class="mt-2 mb-2">Để giải quyết vấn đề này, chúng ta phải nói rõ với trình biên dịch rằng "tôi muốn truyền tham chiếu, không phải bản sao".</p>
						<ul class="list-disc list-inside space-y-2 mt-2">
							<li><strong><code>std::cref(A)</code>:</strong> Viết tắt của "constant reference wrapper". Nó tạo ra một đối tượng bao bọc A để đảm bảo nó được truyền dưới dạng tham chiếu hằng. Luồng có thể đọc A nhưng không thể thay đổi nó.</li>
							<li><strong><code>std::ref(C)</code>:</strong> Viết tắt của "reference wrapper". Nó bao bọc C để đảm bảo nó được truyền dưới dạng tham chiếu không hằng, cho phép luồng ghi kết quả tính toán của mình vào ma trận C gốc.</li>
						</ul>
						
						<p class="font-semibold mt-4">4. Hạn chế: Vấn đề về truy cập bộ nhớ (Cache Locality) 🧠</p>
						<p class="mb-2">Mặc dù nhanh hơn bản tuần tự, phiên bản này vẫn chưa tối ưu. Vấn đề nằm ở cách các luồng truy cập vào ma trận B. Khi tính <code>C[i][j]</code>, vòng lặp k truy cập <code>A.data[i][k]</code> và <code>B.data[k][j]</code>.</p>
						<ul class="list-disc list-inside space-y-2 mt-2">
							<li><strong>Truy cập A:</strong> Các phần tử <code>A.data[i][k]</code> nằm liền kề nhau trong bộ nhớ (truy cập theo hàng). CPU có thể tải trước cả một đoạn của hàng này vào bộ nhớ đệm (cache) tốc độ cao, giúp các lần truy cập tiếp theo rất nhanh. Đây gọi là tính cục bộ tham chiếu không gian (spatial locality) tốt.</li>
							<li><strong>Truy cập B:</strong> Các phần tử <code>B.data[k][j]</code> lại nằm cách xa nhau trong bộ nhớ (truy cập theo cột). Để lấy <code>B[0][j]</code>, <code>B[1][j]</code>, <code>B[2][j]</code>,... CPU phải nhảy đến các hàng khác nhau. Điều này dẫn đến cache miss thường xuyên, tức là dữ liệu cần thiết không có sẵn trong cache và CPU phải chờ để lấy nó từ RAM chính chậm hơn nhiều.</li>
						</ul>
						<p class="mt-2">Khi nhiều luồng cùng thực hiện điều này, chúng có thể "tranh giành" cache của CPU, làm giảm hiệu quả tổng thể. Các phiên bản tối ưu hơn sẽ cố gắng giải quyết vấn đề này, ví dụ bằng cách chuyển vị (transpose) ma trận B trước khi nhân.</p>
					</div>
				</div>
				
				<div class="code-container">
					<h5 class="font-semibold text-lg mt-8 text-cyan-700"><strong>Phiên bản 3</strong>: Đa luồng Tăng tốc</h5>
					<p class="mb-4">Sử dụng biến cục bộ <code class="bg-gray-200 text-cyan-800 font-mono px-1.5 py-1 rounded-md">sum</code> để giảm thiểu truy cập bộ nhớ chung, mang lại hiệu năng cao nhất.</p>
					<div class="code-block" data-example-id="optimized-mult">
<pre><code><span style="color: #5c6370;">// multithread_optimized.cpp</span>
<span style="color: #5c6370;">// Mô tả: Phiên bản nhân ma trận đa luồng được tối ưu hóa.</span>
<span style="color: #5c6370;">// Mỗi luồng tính toán trên biến cục bộ để giảm thiểu truy cập bộ nhớ chung,</span>
<span style="color: #5c6370;">// tránh hiện tượng "False Sharing" và tăng tốc độ đáng kể.</span>

<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">"matrix_utils.h"</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;chrono&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;thread&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;functional&gt;</span>

<span style="color: #5c6370;">// Hàm công việc cho mỗi luồng (phiên bản đã tối ưu)</span>
<span style="color: #c678dd;">void</span> <span style="color: #61afef;">optimized_worker_task</span>(<span style="color: #c678dd;">const</span> Matrix&amp; A, <span style="color: #c678dd;">const</span> Matrix&amp; B, Matrix&amp; C, <span style="color: #d19a66;">int</span> start_row, <span style="color: #d19a66;">int</span> end_row) {
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = start_row; i &lt; end_row; ++i) {
        <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> j = <span style="color: #d19a66;">0</span>; j &lt; B.cols; ++j) {
            <span style="color: #d19a66;">int</span> sum = <span style="color: #d19a66;">0</span>; <span style="color: #5c6370;">// Tối ưu hóa: tính tổng trên biến cục bộ</span>
            <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> k = <span style="color: #d19a66;">0</span>; k &lt; A.cols; ++k) {
                sum += A.data[i][k] * B.data[k][j];
            }
            C.data[i][j] = sum; <span style="color: #5c6370;">// Ghi vào bộ nhớ chung một lần duy nhất</span>
        }
    }
}

<span style="color: #5c6370;">// Hàm điều phối chính (tương tự bản standard, chỉ khác hàm worker)</span>
Matrix <span style="color: #61afef;">multiply_multithreaded_optimized</span>(<span style="color: #c678dd;">const</span> Matrix&amp; A, <span style="color: #c678dd;">const</span> Matrix&amp; B) {
    <span style="color: #d19a66;">unsigned int</span> num_threads = std::thread::hardware_concurrency();
    Matrix C;
    C.rows = A.rows;
    C.cols = B.cols;
    C.data.assign(C.rows, std::vector&lt;<span style="color: #d19a66;">int</span>&gt;(C.cols, <span style="color: #d19a66;">0</span>));
    std::vector&lt;std::thread&gt; threads;
    
    <span style="color: #d19a66;">int</span> rows_per_thread = A.rows / num_threads;

    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">unsigned int</span> i = <span style="color: #d19a66;">0</span>; i &lt; num_threads; ++i) {
        <span style="color: #d19a66;">int</span> start = i * rows_per_thread;
        <span style="color: #d19a66;">int</span> end = (i == num_threads - <span style="color: #d19a66;">1</span>) ? A.rows : start + rows_per_thread;
        threads.emplace_back(optimized_worker_task, std::cref(A), std::cref(B), std::ref(C), start, end);
    }

    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">auto</span>&amp; th : threads) {
        th.join();
    }
    <span style="color: #c678dd;">return</span> C;
}

<span style="color: #d19a66;">int</span> <span style="color: #61afef;">main</span>() {
    <span style="color: #c678dd;">try</span> {
        Matrix A = read_matrix_from_file(<span style="color: #98c379;">"A.txt"</span>);
        Matrix B = read_matrix_from_file(<span style="color: #98c379;">"B.txt"</span>);

        <span style="color: #c678dd;">if</span> (A.cols != B.rows) {
            <span style="color: #c678dd;">throw</span> std::invalid_argument(<span style="color: #98c379;">"Error: Incompatible matrix dimensions."</span>);
        }

        <span style="color: #d19a66;">auto</span> start_time = std::chrono::high_resolution_clock::now();
        Matrix C = multiply_multithreaded_optimized(A, B);
        <span style="color: #d19a66;">auto</span> end_time = std::chrono::high_resolution_clock::now();

        <span style="color: #d19a66;">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_time - start_time);
        std::cout &lt;&lt; <span style="color: #98c379;">"Time taken for OPTIMIZED multi-threading: "</span> &lt;&lt; duration.count() &lt;&lt; <span style="color: #98c379;">" milliseconds\n"</span>;

        write_matrix_to_file(C, <span style="color: #98c379;">"C_multithread_optimized.txt"</span>);
        std::cout &lt;&lt; <span style="color: #98c379;">"Result saved to C_multithread_optimized.txt\n"</span>;

    } <span style="color: #c678dd;">catch</span> (<span style="color: #c678dd;">const</span> std::exception&amp; e) {
        std::cerr &lt;&lt; <span style="color: #98c379;">"An error occurred: "</span> &lt;&lt; e.what() &lt;&lt; std::endl;
        <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">1</span>;
    }
    <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">0</span>;
}
</code></pre>
					</div>
					<div class="explanation-panel hidden mt-4 border-l-4 border-sky-500 bg-sky-50 p-4 rounded-r-lg text-gray-700">
						<h6 class="font-bold text-lg mb-2 text-sky-800">Giải thích sâu hơn</h6>
						<p class="mb-2">Sự khác biệt giữa phiên bản "standard" và "optimized" trông có vẻ rất nhỏ — chỉ là thêm một biến <code>sum</code> cục bộ — nhưng nó lại mang lại một lợi ích hiệu năng rất lớn. Tối ưu hóa này giải quyết một vấn đề tinh vi liên quan đến cách CPU và bộ nhớ tương tác với nhau.</p>

						<p class="font-semibold mt-4">1. Tối ưu hóa Cốt lõi: Local Accumulation (Tích lũy cục bộ) 🧠</p>
						<p class="mb-2">Hãy so sánh hai cách tiếp cận trong vòng lặp trong cùng:</p>
						<ul class="list-disc list-inside space-y-2 mt-2">
							<li>
								<strong>Phiên bản Standard:</strong> <code>C.data[i][j] += A.data[i][k] * B.data[k][j];</code>
								<p class="ml-5 mt-1">Đây là một thao tác Đọc-Sửa-Ghi (Read-Modify-Write) trực tiếp trên bộ nhớ dùng chung (ma trận C). Với mỗi giá trị của <strong>k</strong>, luồng phải đọc giá trị hiện tại của <code>C.data[i][j]</code>, sửa đổi, rồi ghi lại. Thao tác này được lặp lại <code>A.cols</code> lần cho mỗi phần tử của C.</p>
							</li>
							<li>
								<strong>Phiên bản Optimized:</strong> <code>sum += A.data[i][k] * B.data[k][j];</code>
								<p class="ml-5 mt-1">Biến <code>sum</code> là một biến cục bộ (local variable). Trình biên dịch gần như chắc chắn sẽ đặt biến này vào một thanh ghi (CPU register) - bộ nhớ nhanh nhất có trong máy tính. Mọi phép cộng dồn đều diễn ra bên trong CPU với tốc độ cực cao. Chỉ sau khi vòng lặp <strong>k</strong> kết thúc, một thao tác Ghi (Write) duy nhất <code>C.data[i][j] = sum;</code> được thực hiện.</p>
							</li>
						</ul>
						<p class="mt-2"><strong>Kết quả:</strong> Thay vì thực hiện <code>A.cols</code> lượt Đọc-Sửa-Ghi vào bộ nhớ chậm, chúng ta chỉ thực hiện <code>A.cols</code> lượt cộng trong thanh ghi siêu nhanh và chỉ một lần ghi vào bộ nhớ.</p>

						<p class="font-semibold mt-4">2. Tránh hiện tượng "False Sharing" (Chia sẻ giả) 👻</p>
						<p class="mb-2">Đây là một lợi ích sâu xa và quan trọng hơn của việc tối ưu hóa này.</p>
						<ul class="list-disc list-inside space-y-2 mt-2">
							<li><strong>CPU Cache là gì?</strong> CPU không đọc từng byte từ RAM. Thay vào đó, nó đọc cả một khối dữ liệu liền kề gọi là <strong>cache line</strong> (thường là 64 bytes) vào bộ nhớ đệm (cache) tốc độ cao của nó.</li>
							<li><strong>False Sharing xảy ra khi nào?</strong> Nó xảy ra khi nhiều luồng trên các lõi khác nhau cùng sửa đổi các biến khác nhau, nhưng các biến đó lại vô tình nằm trên cùng một cache line.</li>
						</ul>
						<p class="mt-2 mb-2"><strong>Kịch bản:</strong></p>
						<ol class="list-decimal list-inside space-y-1 mt-2 ml-4">
							<li>Giả sử <code>C.data[i][0]</code> và <code>C.data[i][1]</code> nằm trên cùng một cache line.</li>
							<li>Luồng 1 đang tính <code>C.data[i][0]</code> và Luồng 2 đang tính <code>C.data[i][1]</code>.</li>
							<li>Khi Luồng 1 ghi vào <code>C.data[i][0]</code>, toàn bộ cache line chứa nó trên Lõi 2 (của Luồng 2) bị vô hiệu hóa (invalidated).</li>
							<li>Khi Luồng 2 muốn ghi vào <code>C.data[i][1]</code>, nó phải chờ Lõi 1 gửi lại toàn bộ cache line đã được cập nhật.</li>
						</ol>
						<p class="mt-2">Quá trình này lặp đi lặp lại, các lõi CPU liên tục phải đồng bộ hóa một khối bộ nhớ, mặc dù chúng đang làm việc trên các phần tử dữ liệu hoàn toàn độc lập. Bằng cách sử dụng biến <code>sum</code> cục bộ, phiên bản tối ưu đã loại bỏ hoàn toàn các thao tác ghi lặp đi lặp lại vào bộ nhớ chung, do đó triệt tiêu nguy cơ xảy ra False Sharing, cho phép các lõi CPU hoạt động độc lập và hiệu quả hơn nhiều.</p>
					</div>
				</div>
				
				<h5 class="font-semibold text-lg mt-8 text-cyan-700">Lệnh biên dịch và thực thi (trên terminal của Linux/macOS/VSCode)</h5>
                <p class="mb-4">Bạn có thể sử dụng các lệnh sau trong terminal để biên dịch và chạy cả ba phiên bản, sau đó so sánh thời gian thực thi của chúng.</p>
                <div class="code-block">
<pre><code><span style="color: #5c6370;"># 1. Biên dịch các tệp nguồn</span>
g++ sequential_multiplication.cpp -o sequential -std=c++11
g++ multithread_standard.cpp -o standard_mt -std=c++11 -pthread
g++ multithread_optimized.cpp -o optimized_mt -std=c++11 -pthread

<span style="color: #5c6370;"># 2. Thực thi các tệp đã biên dịch</span>
./sequential
./standard_mt
./optimized_mt
</code></pre>
                </div>
			
			<div class="border-t pt-8 mt-8">
				<h4 class="font-bold text-2xl mb-3 text-cyan-700 text-center">6.3. So sánh hiệu năng</h4>
				<p class="mb-8 text-center max-w-3xl mx-auto text-gray-700">Biểu đồ dưới đây minh họa thời gian thực thi của ba phiên bản. Kết quả cho thấy phiên bản lập trình đa luồng cơ bản nhanh hơn <strong>4,4 lần</strong> so với lập trình tuần tự. Quan trọng hơn, phiên bản tăng tốc nhanh hơn <strong>6,8 lần</strong> so với phiên bản tuần tự và <strong>1,5</strong> lần so với phiên bản đa luồng cơ bản, chứng tỏ tác động to lớn của việc tối ưu hóa truy cập bộ nhớ.</p>
				
				<div class="chart-container h-80 md:h-96">
					<canvas id="performanceChart"></canvas>
				</div>
				
				<p class="mt-2 text-center text-gray-400 text-sm italic">* Sau khi chạy xong một chương trình phải khởi động lại máy tính để xóa dữ liệu đã nạp vào RAM từ lần chạy trước.</p>
			</div>
		</section>

    </main>

    <footer class="bg-gray-800 text-white text-center p-4 mt-8">
        <p>Nguyễn Văn Tuấn, Nguyễn Vũ Cường, Đặng Quang Dư, Trần Hữu Mạnh, Đỗ Văn Mạnh, Dương Huy Hoàng - KTVT37</p>
    </footer>

    <button id="backToTopBtn" title="Go to top" class="hidden fixed bottom-5 right-5 bg-cyan-600 text-white p-3 rounded-full shadow-lg hover:bg-cyan-700 transition-colors z-50">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" />
        </svg>
    </button>

<script>
document.addEventListener('DOMContentLoaded', function() {
	
	Chart.register(ChartDataLabels);
    // --- Điều hướng cuộn mượt ---
    document.querySelectorAll('header a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
            e.preventDefault();
            const targetElement = document.querySelector(this.getAttribute('href'));
            if(targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth' });
            }
        });
    });

    // --- Biểu đồ Moore's Law ---
    const mooreCtx = document.getElementById('mooreLawChart').getContext('2d');
    new Chart(mooreCtx, {
        type: 'line',
        data: {
            labels: ['1972', '1978', '1984', '1990', '1996', '2002', '2005', '2008', '2011', '2014', '2017', '2020', '2023', '2026'],
            datasets: [{
                label: 'Chu kỳ trên giây (triệu)',
                data: [2, 4, 10, 50, 300, 3000, 4000, 4500, 4200, 5000, 4800, 5000, 5500, 6000],
				borderColor: 'rgb(0, 0, 0)',
                backgroundColor: 'rgba(0, 0, 0, 0.5)',
                yAxisID: 'y',
                tension: 0.1,
                fill: false,
                pointRadius: 4,
                pointBackgroundColor: 'rgb(0, 0, 0)'
            }, {
                label: 'Số lõi',
                data: [1, 1, 1, 1, 1, 1, 2, 6, 10, 18, 32, 64, 128, 256],
                borderColor: 'rgb(54, 162, 235)',
                backgroundColor: 'rgba(54, 162, 235, 0.5)',
                yAxisID: 'y1',
                tension: 0.1,
                fill: false,
                pointRadius: 4,
                pointBackgroundColor: 'rgb(54, 162, 235)'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: "Tốc độ CPU và số lượng lõi (Thang đo Logarit)"
                },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    callbacks: {
                        label: function(context) {
							let label = context.dataset.label || '';
							if (label) { label += ': '; }
							if (context.parsed.y !== null) {
								if (context.datasetIndex === 0) { // Tốc độ xung nhịp
									// Giá trị bây giờ đã là MHz, chỉ cần thêm đơn vị
									label += context.parsed.y.toLocaleString() + ' MHz';
								} else { // Số lõi
									label += context.parsed.y;
								}
							}
							return label;
						}
                    }
                }
            },
            scales: {
				y: {
					type: 'logarithmic',
					display: true,
					position: 'left',
					title: { display: true, text: 'Chu kỳ trên giây (triệu)' }
				},
                y1: {
                    type: 'logarithmic',
                    display: true,
                    position: 'right',
                    grid: { drawOnChartArea: false },
                    title: { display: true, text: 'Số lõi' },
                    min: 1,
                    ticks: {
                        callback: function(value, index, values) {
                           const coreTicks = [1, 2, 4, 8, 16, 32, 64, 128, 256];
                           if (coreTicks.includes(Number(value))) { return value; }
                        }
                    }
                }
            }
        }
    });

    // --- BIỂU ĐỒ SO SÁNH HIỆU NĂNG (ĐÃ ĐƯỢC THÊM LẠI) ---
    if (document.getElementById('performanceChart')) {
        const perfCtx = document.getElementById('performanceChart').getContext('2d');
        new Chart(perfCtx, {
            type: 'bar',
            data: {
                labels: ['Tuần tự (Đơn luồng)', 'Đa luồng Cơ bản', 'Đa luồng Tăng tốc'],
                datasets: [{
                    label: 'Thời gian thực thi (ms)',
                    data: [43029, 9790, 6363],
                    backgroundColor: [
                        'rgba(239, 68, 68, 0.6)', // Red
                        'rgba(59, 130, 246, 0.6)', // Blue
                        'rgba(22, 163, 74, 0.6)'  // Green
                    ],
                    borderColor: [
                        'rgba(239, 68, 68, 1)',
                        'rgba(59, 130, 246, 1)',
                        'rgba(22, 163, 74, 1)'
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'So sánh thời gian nhân ma trận (càng thấp càng tốt)',
                        align: 'center',
                        font: { size: 18 },
                        padding: { bottom: 20 }
                    },
                    legend: { display: false },
                    // Cấu hình để hiển thị giá trị trên đỉnh cột
                    datalabels: {
                        anchor: 'end',
                        align: 'top',
                        offset: 4,
                        color: '#4A5568',
                        font: {
                            weight: 'bold',
                            size: 13
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Thời gian (mili giây)'
                        }
                    }
                }
            }
        });
    }

    // --- Vòng đời luồng tương tác ---
    const lifecycleStates = [
        { name: 'NEW', color: 'gray', description: 'Đây là trạng thái đầu tiên của luồng sau khi nó được tạo ra (ví dụ, bằng cách khởi tạo một đối tượng std::thread trong C++). Ở trạng thái này, luồng đã tồn tại nhưng chưa bắt đầu thực thi. Mã của nó chưa được chạy, và hệ điều hành chưa cấp phát tài nguyên thực thi cho nó.' },
        { name: 'RUNNABLE', color: 'green', description: 'Sau khi phương thức start() (trong Java) hoặc khi đối tượng std::thread được khởi tạo với một hàm (trong C++), luồng sẽ chuyển sang trạng thái Runnable. "Runnable" không có nghĩa là luồng đang chạy. Nó có nghĩa là luồng đã sẵn sàng để chạy và đang nằm trong hàng đợi, chờ bộ lập lịch (scheduler) của hệ điều hành cấp phát cho nó một lát cắt thời gian (time slice) trên CPU.' },
		{ name: 'RUNNING', color: 'blue', description: 'Khi bộ lập lịch chọn một luồng từ trạng thái Runnable và cấp phát CPU cho nó, luồng đó sẽ chuyển sang trạng thái Running. Đây là trạng thái mà các lệnh của luồng đang thực sự được thực thi.' },
        { name: 'TERMINATED', color: 'purple', description: 'Khi một luồng hoàn thành việc thực thi phương thức chính của nó (ví dụ: phương thức run() trong Java hoặc hàm được truyền cho std::thread trong C++), nó sẽ chuyển sang trạng thái Terminated. Luồng sẽ ngừng hoạt động vĩnh viễn và không thể được khởi động lại.' },
        { name: 'BLOCKED/WAITING', color: 'red', description: 'Một luồng đang chạy có thể chuyển sang trạng thái bị chặn vì nhiều lý do. Ở trạng thái này, luồng tạm thời ngừng thực thi và không sử dụng CPU, chờ đợi một sự kiện nào đó xảy ra.Các nguyên nhân phổ biến bao gồm: <br> - Luồng đang cố gắng chiếm một khóa (lock) mà một luồng khác đang giữ.<br>- Luồng gọi một phương thức gây chặn, ví dụ như chờ dữ liệu từ mạng hoặc đĩa (I/O operation).<br>- Luồng tự nguyện đi vào trạng thái chờ bằng cách gọi các phương thức như sleep(), wait(), hoặc join() trên một luồng khác. <br> Khi sự kiện mà luồng đang chờ đợi xảy ra (ví dụ: khóa được giải phóng, dữ liệu I/O có sẵn), luồng sẽ quay trở lại trạng thái Runnable, sẵn sàng để được lập lịch chạy lại.' }
    ];

    const topRowContainer = document.getElementById('lifecycle-top-row');
    const bottomRowContainer = document.getElementById('lifecycle-bottom-row');
    const detailsPanel = document.getElementById('lifecycle-details');
    let activeStateElement = null;

    // Hàm tạo một khối trạng thái
    const createStateElement = (state) => {
        const stateEl = document.createElement('div');
        stateEl.className = `cursor-pointer p-3 rounded-lg border-2 bg-white transition-all shadow-sm hover:shadow-md hover:scale-105 border-${state.color}-300`;
        stateEl.textContent = state.name;
        stateEl.dataset.description = state.description;
        stateEl.dataset.color = state.color;
        
        stateEl.addEventListener('click', () => {
            if (activeStateElement) {
                const oldColor = activeStateElement.dataset.color;
                activeStateElement.classList.remove(`bg-${oldColor}-200`, `border-${oldColor}-500`, 'scale-110');
                activeStateElement.classList.add(`bg-white`, `border-${oldColor}-300`);
            }
            detailsPanel.innerHTML = `<h5 class="font-bold text-lg text-${state.color}-600 mb-2">${state.name}</h5><p>${state.description}</p>`;
            stateEl.classList.add(`bg-${state.color}-200`, `border-${state.color}-500`, 'scale-110');
            stateEl.classList.remove(`bg-white`, `border-${state.color}-300`);
            activeStateElement = stateEl;
        });
        return stateEl;
    };

    // Hàm tạo một mũi tên
    const createArrowElement = (content) => {
        const arrow = document.createElement('div');
        arrow.className = 'text-2xl text-gray-400';
        arrow.innerHTML = content;
        return arrow;
    };

    // Điền các trạng thái vào đúng tầng
    lifecycleStates.forEach(state => {
        if (state.name === 'BLOCKED/WAITING') {
            bottomRowContainer.appendChild(createStateElement(state));
        } else {
            // Nếu không phải trạng thái đầu tiên thì thêm mũi tên vào trước
            if (topRowContainer.hasChildNodes()) {
                const arrowContent = (state.name === 'RUNNING') ? '&leftrightarrow;' : '&rarr;';
                topRowContainer.appendChild(createArrowElement(arrowContent));
            }
            topRowContainer.appendChild(createStateElement(state));
        }
    });

    // --- Chuyển Tab cho Vấn đề thường gặp ---
    const tabOverall = document.getElementById('tab-overall'), tabRace = document.getElementById('tab-race'), tabDeadlock = document.getElementById('tab-deadlock'), tabOther = document.getElementById('tab-other');
    const contentOverall = document.getElementById('content-tab-overall'), contentRace = document.getElementById('content-race'), contentDeadlock = document.getElementById('content-deadlock'), contentOther = document.getElementById('content-other');
    const allTabs = [tabOverall, tabRace, tabDeadlock, tabOther], allContents = [contentOverall, contentRace, contentDeadlock, contentOther];
    const switchTab = (activeIndex) => {
        allContents.forEach((c, i) => c.classList.toggle('hidden', i !== activeIndex));
        allTabs.forEach((t, i) => {
            t.classList.toggle('border-cyan-500', i === activeIndex);
            t.classList.toggle('text-cyan-600', i === activeIndex);
            t.classList.toggle('border-transparent', i !== activeIndex);
            t.classList.toggle('text-gray-500', i !== activeIndex);
        });
    };
	tabOverall.addEventListener('click', () => switchTab(0));
    tabRace.addEventListener('click', () => switchTab(1));
    tabDeadlock.addEventListener('click', () => switchTab(2));
    tabOther.addEventListener('click', () => switchTab(3));

    // --- Mô phỏng Race Condition ---
    const counterValueEl = document.getElementById('counter-value'),
          startUnsyncedBtn = document.getElementById('start-step-unsynced'),
          startSyncedBtn = document.getElementById('start-step-synced'),
          runNextStepBtn = document.getElementById('run-next-step'),
          resetCounterBtn = document.getElementById('reset-counter'), // Thêm lại nút Reset
          simLogEl = document.getElementById('simulation-log');

    let balance = 1000, currentStep = 0;
    let tempBalanceA = 0, tempBalanceB = 0;
    let activeSteps = null;

    const unsyncedSteps = [
        () => { log('Bắt đầu mô phỏng <strong class="text-red-500">KHÔNG</strong> đồng bộ...'); },
        () => { tempBalanceA = balance; log(`Luồng A (rút tiền) đọc số dư: ${tempBalanceA}`); },
        () => { tempBalanceB = balance; log(`Luồng B (nạp tiền) đọc số dư: ${tempBalanceB}`); },
        () => { tempBalanceB += 200; balance = tempBalanceB; log(`Luồng B ghi số dư mới: <strong class="text-blue-500">${balance}</strong>`); counterValueEl.textContent = balance; },
        () => { tempBalanceA -= 100; balance = tempBalanceA; log(`Luồng A ghi đè số dư: <strong class="text-red-500">${balance}</strong>`); counterValueEl.textContent = balance; },
        () => { log(`Kết quả cuối cùng: <strong class="text-red-500">${balance}</strong>.`); runNextStepBtn.disabled = true; }
    ];

    const syncedSteps = [
        () => { log('Bắt đầu mô phỏng <strong class="text-green-500">CÓ</strong> đồng bộ...'); },
        () => { log('Luồng A yêu cầu khóa...'); },
        () => { balance -= 100; log(`Luồng A khóa thành công và rút tiền. Số dư mới: <strong class="text-green-600">${balance}</strong>`); counterValueEl.textContent = balance; },
        () => { log('Luồng A giải phóng khóa.'); },
        () => { log('Luồng B yêu cầu khóa...'); },
        () => { balance += 200; log(`Luồng B khóa thành công và nạp tiền. Số dư mới: <strong class="text-green-600">${balance}</strong>`); counterValueEl.textContent = balance; },
        () => { log('Luồng B giải phóng khóa.'); },
        () => { log(`Kết quả đúng: <strong class="text-green-500">${balance}</strong>.`); runNextStepBtn.disabled = true; }
    ];

    const log = (message) => { simLogEl.innerHTML += `<div>${message}</div>`; simLogEl.scrollTop = simLogEl.scrollHeight; };

    const setupSimulation = (stepsArray) => {
        resetCounter(true);
        activeSteps = stepsArray;
        currentStep = 0;
        
        // Ẩn các nút "Bắt đầu", hiện các nút "Bước tiếp theo" và "Reset"
        startUnsyncedBtn.classList.add('hidden');
        startSyncedBtn.classList.add('hidden');
        runNextStepBtn.classList.remove('hidden');
        resetCounterBtn.classList.remove('hidden');
        runNextStepBtn.disabled = false;

        runNextStepBtn.click();
    };

    const resetCounter = (isPartial = false) => {
        balance = 1000;
        currentStep = 0;
        activeSteps = null;
        counterValueEl.textContent = balance;
        simLogEl.innerHTML = 'Nhấn nút "Bắt đầu..." để mô phỏng giao dịch.<br>Mong đợi: 1000 - 100 + 200 = 1100.';
        
        // Hiện lại các nút "Bắt đầu", ẩn các nút "Bước tiếp theo" và "Reset"
        startUnsyncedBtn.classList.remove('hidden');
        startSyncedBtn.classList.remove('hidden');
        runNextStepBtn.classList.add('hidden');
        resetCounterBtn.classList.add('hidden');
        
        if (isPartial) {
             simLogEl.innerHTML = '';
        }
    };
    
    // Thêm lại sự kiện cho nút Reset
    resetCounterBtn.addEventListener('click', () => resetCounter(false));
    startUnsyncedBtn.addEventListener('click', () => setupSimulation(unsyncedSteps));
    startSyncedBtn.addEventListener('click', () => setupSimulation(syncedSteps));

    runNextStepBtn.addEventListener('click', () => {
        if (activeSteps && currentStep < activeSteps.length) {
            activeSteps[currentStep]();
            currentStep++;
        }
    });

    // Gọi resetCounter một lần khi tải trang để đảm bảo trạng thái ban đầu đúng
    resetCounter();

    // --- Mô phỏng Deadlock (5 Philosophers) ---
    const runDeadlockBtn = document.getElementById('run-deadlock-step'); // Đổi tên từ StepBtn cho gọn
    const resetDeadlockBtn = document.getElementById('reset-deadlock'); // Nút Reset mới
    const deadlockStatusEl = document.getElementById('deadlock-status');
    const deadlockCircle = document.getElementById('deadlock-circle');
    const NUM_PHILOSOPHERS = 5;
    const philosophers = [], forks = [];
    let currentDeadlockStep = 0;

    // Tạo và định vị các triết gia và nĩa
    for (let i = 0; i < NUM_PHILOSOPHERS; i++) {
        const angleP = (i / NUM_PHILOSOPHERS) * 2 * Math.PI - Math.PI / 2;
        const p = document.createElement('div');
        p.className = 'philosopher'; p.id = `p${i}`; p.textContent = `P${i}`;
        p.style.left = `${150 + 120 * Math.cos(angleP) - 30}px`;
        p.style.top = `${150 + 120 * Math.sin(angleP) - 30}px`;
        philosophers.push(p); deadlockCircle.appendChild(p);
        
        const angleF = angleP + (Math.PI / NUM_PHILOSOPHERS);
        const f = document.createElement('div');
        f.className = 'fork'; f.id = `f${i}`; f.innerHTML = '🍴';
        f.style.left = `${150 + 75 * Math.cos(angleF) - 20}px`;
        f.style.top = `${150 + 75 * Math.sin(angleF) - 20}px`;
        forks.push(f); deadlockCircle.appendChild(f);
    }
    
    // Hàm reset trạng thái mô phỏng
    const resetDeadlock = () => {
        currentDeadlockStep = 0;
        deadlockStatusEl.textContent = "Nhấn 'Chạy' để bắt đầu.";
        deadlockStatusEl.className = "text-lg font-medium h-8 text-center text-gray-700";
        philosophers.forEach(p => p.className = 'philosopher');
        forks.forEach(f => f.className = 'fork');
        runDeadlockBtn.disabled = false;
    };

    // Mảng chứa các bước của mô phỏng
    const deadlockSteps = [
        () => {
            deadlockStatusEl.textContent = `P0 cầm nĩa trái (F0)...`;
            forks[0].classList.add('bg-blue-200', 'border-blue-500');
            philosophers[0].classList.add('scale-110');
        },
        () => {
            deadlockStatusEl.textContent = `P1 cầm nĩa trái (F1)...`;
            forks[1].classList.add('bg-blue-200', 'border-blue-500');
            philosophers[1].classList.add('scale-110');
        },
        () => {
            deadlockStatusEl.textContent = `P2 cầm nĩa trái (F2)...`;
            forks[2].classList.add('bg-blue-200', 'border-blue-500');
            philosophers[2].classList.add('scale-110');
        },
        () => {
            deadlockStatusEl.textContent = `P3 cầm nĩa trái (F3)...`;
            forks[3].classList.add('bg-blue-200', 'border-blue-500');
            philosophers[3].classList.add('scale-110');
        },
        () => {
            deadlockStatusEl.textContent = `P4 cầm nĩa trái (F4)...`;
            forks[4].classList.add('bg-blue-200', 'border-blue-500');
            philosophers[4].classList.add('scale-110');
        },
        () => { deadlockStatusEl.textContent = "Tất cả đang chờ nĩa phải..."; },
        () => {
            deadlockStatusEl.textContent = "DEADLOCK!";
            deadlockStatusEl.className = "text-lg font-bold h-8 text-center text-red-600 animate-pulse";
            philosophers.forEach(p => p.classList.add('bg-red-200', 'border-red-500'));
            runDeadlockBtn.disabled = true; // Kết thúc, vô hiệu hóa nút Chạy
        }
    ];

    // Sự kiện cho nút Chạy
    runDeadlockBtn.addEventListener('click', () => {
        if (currentDeadlockStep === 0) { // Lần click đầu tiên sẽ reset nhẹ
            resetDeadlock();
            deadlockStatusEl.textContent = "Bắt đầu từng bước...";
        }
        if (currentDeadlockStep < deadlockSteps.length) {
            deadlockSteps[currentDeadlockStep]();
            currentDeadlockStep++;
        }
    });

    // Sự kiện cho nút Reset mới
    resetDeadlockBtn.addEventListener('click', resetDeadlock);

    // Đặt trạng thái ban đầu khi tải trang
    resetDeadlock();

    // --- Nút Trở về đầu trang ---
    const backToTopBtn = document.getElementById('backToTopBtn');
    window.onscroll = function() {
        if (document.body.scrollTop > 100 || document.documentElement.scrollTop > 100) {
            backToTopBtn.classList.remove('hidden');
        } else {
            backToTopBtn.classList.add('hidden');
        }
    };
    backToTopBtn.addEventListener('click', function() {
        window.scrollTo({top: 0, behavior: 'smooth'});
    });
	
	// --- SCRIPT TỔNG QUÁT CHO CHỨC NĂNG GIẢI THÍCH VÀ SAO CHÉP ---

    const exampleContents = {
        'race-condition-error': {
            explained: `<span style="color: #5c6370;">// Thư viện cần thiết</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;iostream&gt;</span> <span style="color: #5c6370;">// Cho việc nhập/xuất (std::cout)</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;thread&gt;</span>   <span style="color: #5c6370;">// Cho việc tạo và quản lý luồng (std::thread)</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;vector&gt;</span>   <span style="color: #5c6370;">// Để lưu trữ danh sách các luồng (std::vector)</span>

<span style="color: #5c6370;">// Biến toàn cục, được chia sẻ bởi tất cả các luồng</span>
<span style="color: #d19a66;">long long</span> counter = <span style="color: #d19a66;">0</span>;

<span style="color: #5c6370;">// Hàm sẽ được thực thi bởi mỗi luồng</span>
<span style="color: #c678dd;">void</span> <span style="color: #61afef;">increment</span>() {
    <span style="color: #5c6370;">// Vòng lặp 100,000 lần</span>
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">100000</span>; ++i) {
        <span style="color: #5c6370;">// Thao tác tăng biến đếm. Đây là điểm mấu chốt gây ra lỗi!</span>
        counter++; <span style="color: #e06c75;">// Thao tác này không nguyên tử (non-atomic)</span>
    }
}

<span style="color: #d19a66;">int</span> <span style="color: #61afef;">main</span>() {
    <span style="color: #5c6370;">// Tạo một vector để chứa các đối tượng luồng</span>
    std::vector&lt;std::thread&gt; threads;

    <span style="color: #5c6370;">// Tạo và khởi chạy 10 luồng</span>
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">10</span>; ++i) {
        <span style="color: #5c6370;">// Mỗi luồng được tạo ra sẽ chạy hàm increment()</span>
        threads.push_back(std::thread(increment));
    }

    <span style="color: #5c6370;">// Đợi tất cả các luồng hoàn thành công việc</span>
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">auto</span>&amp; th : threads) {
        <span style="color: #5c6370;">// main() sẽ bị block ở đây cho đến khi luồng 'th' kết thúc</span>
        th.join();
    }

    <span style="color: #5c6370;">// In ra giá trị cuối cùng của counter</span>
    <span style="color: #5c6370;">// Kết quả thường sẽ nhỏ hơn 1,000,000 (10 luồng * 100,000)</span>
    std::cout &lt;&lt; <span style="color: #98c379;">"Final counter: "</span> &lt;&lt; counter &lt;&lt; std::endl;
    <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">0</span>;
}`
        },
        'mutex-fix': {
            explained: `<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;iostream&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;thread&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;vector&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;mutex&gt;</span> <span style="color: #5c6370;">// Thêm thư viện mutex</span>

<span style="color: #5c6370;">// Biến toàn cục, được chia sẻ</span>
<span style="color: #d19a66;">long long</span> counter = <span style="color: #d19a66;">0</span>;
<span style="color: #5c6370;">// Khai báo một đối tượng mutex toàn cục</span>
std::mutex mtx;

<span style="color: #5c6370;">// Hàm được bảo vệ, sẽ được thực thi bởi mỗi luồng</span>
<span style="color: #c678dd;">void</span> <span style="color: #61afef;">increment_safe</span>() {
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">100000</span>; ++i) {
        <span style="color: #5c6370;">// Tạo một đối tượng lock_guard. Ngay khi được tạo, nó sẽ</span>
        <span style="color: #5c6370;">// tự động khóa (lock) mutex 'mtx'.</span>
        <span style="color: #98c379;">std::lock_guard&lt;std::mutex&gt; lock(mtx);</span>

        <span style="color: #5c6370;">// Bất kỳ đoạn code nào trong scope này đều là "vùng găng" (critical section).</span>
        <span style="color: #5c6370;">// Tại một thời điểm, chỉ có DUY NHẤT một luồng được phép thực thi code ở đây.</span>
        counter++;
    } <span style="color: #5c6370;">// Khi 'lock' ra khỏi scope (kết thúc vòng lặp), nó sẽ tự động</span>
      <span style="color: #5c6370;">// được hủy và mutex 'mtx' sẽ được mở khóa (unlock).</span>
}

<span style="color: #d19a66;">int</span> <span style="color: #61afef;">main</span>() {
    std::vector&lt;std::thread&gt; threads;
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">10</span>; ++i) {
        <span style="color: #5c6370;">// Tạo 10 luồng, mỗi luồng chạy hàm increment_safe đã được bảo vệ</span>
        threads.push_back(std::thread(increment_safe));
    }

    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">auto</span>&amp; th : threads) {
        th.join();
    }

    <span style="color: #5c6370;">// Kết quả luôn luôn là 1,000,000</span>
    std::cout &lt;&lt; <span style="color: #98c379;">"Final counter: "</span> &lt;&lt; counter &lt;&lt; std::endl;
    <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">0</span>;
}`
        },
        'semaphore-worker': {
            explained: `<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;iostream&gt;</span>      <span style="color: #5c6370;">// Cho việc nhập/xuất (std::cout)</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;thread&gt;</span>        <span style="color: #5c6370;">// Cho việc tạo và quản lý luồng (std::thread)</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;vector&gt;</span>        <span style="color: #5c6370;">// Để lưu trữ danh sách các luồng (std::vector)</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;semaphore&gt;</span>     <span style="color: #5c6370;">// Cho semaphore (std::counting_semaphore)</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;chrono&gt;</span>        <span style="color: #5c6370;">// Cho các chức năng về thời gian (std::this_thread::sleep_for)</span>

<span style="color: #5c6370;">// Khởi tạo một counting_semaphore.</span>
<span style="color: #5c6370;">// Con số &lt;3&gt; trong template nghĩa là giá trị tối đa của bộ đếm là 3.</span>
<span style="color: #5c6370;">// Con số (3) trong hàm khởi tạo nghĩa là giá trị ban đầu của bộ đếm là 3.</span>
<span style="color: #5c6370;">// Tương đương với việc có 3 "slot" (chỗ trống) hoặc "giấy phép" ban đầu.</span>
std::counting_semaphore&lt;<span style="color: #d19a66;">3</span>&gt; worker_slots(<span style="color: #d19a66;">3</span>);

<span style="color: #5c6370;">// Hàm này sẽ được thực thi bởi mỗi luồng (mỗi "worker")</span>
<span style="color: #c678dd;">void</span> <span style="color: #61afef;">worker</span>(<span style="color: #d19a66;">int</span> id) {
    <span style="color: #5c6370;">// In ra thông báo rằng worker này đang bắt đầu và đang chờ</span>
    std::cout &lt;&lt; <span style="color: #98c379;">"Worker "</span> &lt;&lt; id &lt;&lt; <span style="color: #98c379;">" is waiting for a slot...\\n"</span>;
    
    <span style="color: #5c6370;">// Yêu cầu một slot từ semaphore.</span>
    <span style="color: #5c6370;">// - Nếu bộ đếm &gt; 0, luồng sẽ lấy 1 slot (bộ đếm giảm đi 1) và đi tiếp ngay lập tức.</span>
    <span style="color: #5c6370;">// - Nếu bộ đếm == 0 (hết slot), luồng sẽ bị block (dừng) ở đây và chờ cho đến khi có luồng khác giải phóng slot.</span>
    worker_slots.acquire(); 
    
    <span style="color: #5c6370;">// Khi luồng vượt qua được dòng acquire(), nó đã chiếm được một slot.</span>
    std::cout &lt;&lt; <span style="color: #98c379;">"Worker "</span> &lt;&lt; id &lt;&lt; <span style="color: #98c379;">" has acquired a slot and is working.\\n"</span>;
    
    <span style="color: #5c6370;">// Giả lập một công việc tốn thời gian (ví dụ: xử lý dữ liệu, truy cập file...)</span>
    <span style="color: #5c6370;">// Luồng sẽ "ngủ" trong 2 giây.</span>
    std::this_thread::sleep_for(std::chrono::seconds(<span style="color: #d19a66;">2</span>)); 
    
    std::cout &lt;&lt; <span style="color: #98c379;">"Worker "</span> &lt;&lt; id &lt;&lt; <span style="color: #98c379;">" has finished and is releasing the slot.\\n"</span>;
    
    <span style="color: #5c6370;">// Sau khi làm xong việc, luồng phải giải phóng slot đã chiếm.</span>
    <span style="color: #5c6370;">// Thao tác này làm tăng bộ đếm của semaphore lên 1.</span>
    <span style="color: #5c6370;">// Việc này cho phép một luồng khác đang chờ ở acquire() có thể đi tiếp.</span>
    worker_slots.release();
}

<span style="color: #d19a66;">int</span> <span style="color: #61afef;">main</span>() {
    <span style="color: #5c6370;">// Tạo một vector để chứa các đối tượng luồng</span>
    std::vector&lt;std::thread&gt; workers;

    <span style="color: #5c6370;">// Tạo và khởi chạy 10 luồng worker</span>
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">10</span>; ++i) {
        <span style="color: #5c6370;">// Mỗi luồng được tạo ra sẽ chạy hàm worker() với id tương ứng (0 đến 9)</span>
        workers.emplace_back(worker, i);
    }

    <span style="color: #5c6370;">// Đợi tất cả các luồng worker hoàn thành công việc của chúng</span>
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">auto</span>&amp; w : workers) {
        w.join();
    }

    <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">0</span>;
}`
        },
        'producer-consumer': {
            explained: `<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;iostream&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;thread&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;queue&gt;</span>                <span style="color: #5c6370;">// Hàng đợi (First-In, First-Out) để làm bộ đệm</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;mutex&gt;</span>                <span style="color: #5c6370;">// Để bảo vệ buffer</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;condition_variable&gt;</span>   <span style="color: #5c6370;">// Để chờ và thông báo điều kiện</span>

<span style="color: #5c6370;">// ----- Các tài nguyên được chia sẻ -----</span>
std::queue&lt;<span style="color: #d19a66;">int</span>&gt; buffer;         <span style="color: #5c6370;">// Bộ đệm chung, chứa các số nguyên</span>
std::mutex mtx;                 <span style="color: #5c6370;">// Mutex để bảo vệ việc truy cập vào buffer</span>
std::condition_variable cv;     <span style="color: #5c6370;">// Biến điều kiện để đồng bộ hóa producer và consumer</span>
<span style="color: #c678dd;">const unsigned int</span> MAX_BUFFER_SIZE = <span style="color: #d19a66;">5</span>; <span style="color: #5c6370;">// Kích thước tối đa của bộ đệm</span>

<span style="color: #5c6370;">// ----- Luồng Producer (Nhà sản xuất) -----</span>
<span style="color: #c678dd;">void</span> <span style="color: #61afef;">producer</span>(<span style="color: #d19a66;">int</span> id) {
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">10</span>; ++i) {
        <span style="color: #5c6370;">// Khóa mutex. std::unique_lock linh hoạt hơn lock_guard,</span>
        <span style="color: #5c6370;">// cho phép chúng ta tự mở khóa (unlock) trước khi ra khỏi scope.</span>
        std::unique_lock&lt;std::mutex&gt; lock(mtx);
        
        <span style="color: #5c6370;">// Chờ đợi cho đến khi buffer không còn đầy.</span>
        <span style="color: #5c6370;">// cv.wait sẽ:</span>
        <span style="color: #5c6370;">// 1. Kiểm tra điều kiện (lambda function \`[]{ return buffer.size() &lt; MAX_BUFFER_SIZE; }\`).</span>
        <span style="color: #5c6370;">// 2. Nếu điều kiện sai (buffer đang đầy), nó sẽ tự động MỞ KHÓA mutex và đưa luồng này vào trạng thái ngủ.</span>
        <span style="color: #5c6370;">// 3. Khi luồng khác gọi notify(), luồng này sẽ thức dậy, KHÓA LẠI mutex và kiểm tra lại điều kiện.</span>
        cv.wait(lock, []{ <span style="color: #c678dd;">return</span> buffer.size() &lt; MAX_BUFFER_SIZE; });
        
        <span style="color: #5c6370;">// Khi điều kiện đã thỏa mãn (buffer có chỗ trống), thêm một item vào</span>
        buffer.push(i);
        std::cout &lt;&lt; <span style="color: #98c379;">"Producer "</span> &lt;&lt; id &lt;&lt; <span style="color: #98c379;">" produced item "</span> &lt;&lt; i &lt;&lt; <span style="color: #98c379;">".\\n"</span>;
        
        <span style="color: #5c6370;">// Mở khóa mutex sớm để consumer có thể vào làm việc ngay</span>
        <span style="color: #5c6370;">// mà không cần đợi producer kết thúc các thao tác khác.</span>
        lock.unlock();
        
        <span style="color: #5c6370;">// Thông báo cho MỘT luồng đang chờ (có thể là consumer) rằng có điều gì đó đã thay đổi.</span>
        <span style="color: #5c6370;">// Consumer đang chờ buffer không rỗng sẽ được đánh thức.</span>
        cv.notify_one();
    }
}

<span style="color: #5c6370;">// ----- Luồng Consumer (Người tiêu dùng) -----</span>
<span style="color: #c678dd;">void</span> <span style="color: #61afef;">consumer</span>(<span style="color: #d19a66;">int</span> id) {
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">10</span>; ++i) {
        <span style="color: #5c6370;">// Khóa mutex để chuẩn bị truy cập buffer</span>
        std::unique_lock&lt;std::mutex&gt; lock(mtx);
        
        <span style="color: #5c6370;">// Chờ đợi cho đến khi buffer không còn rỗng.</span>
        <span style="color: #5c6370;">// Tương tự như producer, nếu buffer đang rỗng, luồng này sẽ ngủ</span>
        <span style="color: #5c6370;">// và tạm thời nhả khóa mutex ra.</span>
        cv.wait(lock, []{ <span style="color: #c678dd;">return</span> !buffer.empty(); });
        
        <span style="color: #5c6370;">// Khi điều kiện đã thỏa mãn (buffer có item), lấy item ra</span>
        <span style="color: #d19a66;">int</span> item = buffer.front();
        buffer.pop();
        std::cout &lt;&lt; <span style="color: #98c379;">"Consumer "</span> &lt;&lt; id &lt;&lt; <span style="color: #98c379;">" consumed item "</span> &lt;&lt; item &lt;&lt; <span style="color: #98c379;">".\\n"</span>;
        
        <span style="color: #5c6370;">// Mở khóa mutex</span>
        lock.unlock();
        
        <span style="color: #5c6370;">// Thông báo cho MỘT luồng đang chờ (có thể là producer) rằng có điều gì đó đã thay đổi.</span>
        <span style="color: #5c6370;">// Producer đang chờ buffer có chỗ trống sẽ được đánh thức.</span>
        cv.notify_one();
    }
}

<span style="color: #d19a66;">int</span> <span style="color: #61afef;">main</span>() {
    <span style="color: #5c6370;">// Tạo 1 luồng producer và 1 luồng consumer</span>
    std::thread p1(producer, 1);
    std::thread c1(consumer, 1);
    
    <span style="color: #5c6370;">// Đợi cả hai luồng hoàn thành công việc</span>
    p1.join();
    c1.join();
    
    <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">0</span>;
}`
        },
        'atomic-counter': {
            explained: `<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;iostream&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;thread&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;vector&gt;</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;atomic&gt;</span> <span style="color: #5c6370;">// Thêm thư viện atomic</span>

<span style="color: #5c6370;">// Khai báo một biến counter kiểu long long, nhưng bọc trong template std::atomic.</span>
<span style="color: #5c6370;">// Mọi thao tác trên biến này giờ đây sẽ tuân theo các quy tắc nguyên tử.</span>
<span style="color: #5c6370;">// Khởi tạo giá trị ban đầu là 0.</span>
std::atomic&lt;<span style="color: #d19a66;">long long</span>&gt; atomic_counter(<span style="color: #d19a66;">0</span>);

<span style="color: #5c6370;">// Hàm sẽ được thực thi bởi mỗi luồng</span>
<span style="color: #c678dd;">void</span> <span style="color: #61afef;">increment_atomic</span>() {
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">100000</span>; ++i) {
        <span style="color: #5c6370;">// Đây là điểm mấu chốt.</span>
        <span style="color: #5c6370;">// fetch_add là một thao tác Read-Modify-Write (Đọc-Sửa-Ghi) nguyên tử.</span>
        <span style="color: #5c6370;">// Nó đảm bảo rằng việc đọc giá trị hiện tại của counter,</span>
        <span style="color: #5c6370;">// cộng thêm 1, và ghi lại giá trị mới là một hành động duy nhất, không thể bị chia cắt.</span>
        <span style="color: #5c6370;">// Nó tương đương với thao tác \`atomic_counter++\` nhưng rõ ràng hơn về mặt ý nghĩa.</span>
        <span style="color: #5c6370;">// \`std::memory_order_relaxed\` là một tùy chọn tối ưu hóa, cho trình biên dịch biết</span>
        <span style="color: #5c6370;">// rằng không cần đồng bộ hóa bộ nhớ phức tạp với các biến atomic khác.</span>
        <span style="color: #5c6370;">// Đối với một biến đếm đơn giản, đây là lựa chọn hiệu quả nhất.</span>
        atomic_counter.fetch_add(<span style="color: #d19a66;">1</span>, std::memory_order_relaxed);
    }
}

<span style="color: #d19a66;">int</span> <span style="color: #61afef;">main</span>() {
    std::vector&lt;std::thread&gt; threads;
    <span style="color: #5c6370;">// Tạo và khởi chạy 10 luồng</span>
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; <span style="color: #d19a66;">10</span>; ++i) {
        threads.push_back(std::thread(increment_atomic));
    }

    <span style="color: #5c6370;">// Đợi tất cả các luồng hoàn thành</span>
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">auto</span>&amp; th : threads) {
        th.join();
    }

    <span style="color: #5c6370;">// Để đọc giá trị từ một biến atomic một cách an toàn, ta dùng phương thức load().</span>
    <span style="color: #5c6370;">// Điều này đảm bảo rằng chúng ta đọc được giá trị hoàn chỉnh cuối cùng,</span>
    <span style="color: #5c6370;">// không phải một giá trị đang được cập nhật dở dang.</span>
    std::cout &lt;&lt; <span style="color: #98c379;">"Final counter: "</span> &lt;&lt; atomic_counter.load() &lt;&lt; std::endl; <span style="color: #5c6370;">// Kết quả luôn là 1,000,000</span>
    <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">0</span>;
}`
        }, // <--- Đảm bảo bạn có dấu phẩy ở đây để ngăn cách các mục

        // --- BẮT ĐẦU PHẦN MÃ MỚI CẦN THÊM ---
        'matrix-utils': {
            explained: `<span style="color: #5c6370;">// Header Guards: Đảm bảo tệp chỉ được biên dịch một lần.</span>
<span style="color: #c678dd;">#ifndef</span> <span style="color: #e5c07b;">MATRIX_UTILS_H</span>
<span style="color: #c678dd;">#define</span> <span style="color: #e5c07b;">MATRIX_UTILS_H</span>

<span style="color: #5c6370;">// Khai báo các thư viện chuẩn cần thiết</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;vector&gt;</span>   <span style="color: #5c6370;">// Để lưu trữ dữ liệu ma trận</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;string&gt;</span>   <span style="color: #5c6370;">// Để làm việc với tên tệp</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;fstream&gt;</span>  <span style="color: #5c6370;">// Để đọc/ghi tệp</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;stdexcept&gt;</span> <span style="color: #5c6370;">// Để xử lý lỗi</span>

<span style="color: #5c6370;">// Định nghĩa cấu trúc Matrix để đóng gói dữ liệu</span>
<span style="color: #c678dd;">struct</span> <span style="color: #e5c07b;">Matrix</span> {
    <span style="color: #d19a66;">int</span> rows = <span style="color: #d19a66;">0</span>;
    <span style="color: #d19a66;">int</span> cols = <span style="color: #d19a66;">0</span>;
    std::vector&lt;std::vector&lt;<span style="color: #d19a66;">int</span>&gt;&gt; data;
};

<span style="color: #5c6370;">// Hàm đọc ma trận từ file</span>
<span style="color: #c678dd;">inline</span> Matrix <span style="color: #61afef;">read_matrix_from_file</span>(<span style="color: #c678dd;">const</span> std::string&amp; filename) {
    std::ifstream file(filename);
    <span style="color: #c678dd;">if</span> (!file.is_open()) {
        <span style="color: #c678dd;">throw</span> std::runtime_error(<span style="color: #98c379;">"Error: Could not open file "</span> + filename);
    }
    Matrix mat;
    file &gt;&gt; mat.rows &gt;&gt; mat.cols;
    mat.data.assign(mat.rows, std::vector&lt;<span style="color: #d19a66;">int</span>&gt;(mat.cols));
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; mat.rows; ++i) {
        <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> j = <span style="color: #d19a66;">0</span>; j &lt; mat.cols; ++j) {
            file &gt;&gt; mat.data[i][j];
        }
    }
    <span style="color: #c678dd;">return</span> mat;
}

<span style="color: #5c6370;">// Hàm ghi ma trận ra file</span>
<span style="color: #c678dd;">inline</span> <span style="color: #c678dd;">void</span> <span style="color: #61afef;">write_matrix_to_file</span>(<span style="color: #c678dd;">const</span> Matrix&amp; mat, <span style="color: #c678dd;">const</span> std::string&amp; filename) {
    std::ofstream file(filename);
    file &lt;&lt; mat.rows &lt;&lt; <span style="color: #98c379;">" "</span> &lt;&lt; mat.cols &lt;&lt; <span style="color: #98c379;">"\\n"</span>;
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; mat.rows; ++i) {
        <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> j = <span style="color: #d19a66;">0</span>; j &lt; mat.cols; ++j) {
            file &lt;&lt; mat.data[i][j] &lt;&lt; (j == mat.cols - <span style="color: #d19a66;">1</span> ? <span style="color: #98c379;">""</span> : <span style="color: #98c379;">" "</span>);
        }
        file &lt;&lt; <span style="color: #98c379;">"\\n"</span>;
    }
}
<span style="color: #c678dd;">#endif</span>`
        },
        'sequential-mult': {
            explained: `<span style="color: #5c6370;">// sequential_multiplication.cpp</span>
<span style="color: #5c6370;">// Mô tả: Chương trình này thực hiện phép nhân hai ma trận một cách tuần tự,</span>
<span style="color: #5c6370;">// tức là chỉ sử dụng một luồng (luồng chính).</span>
<span style="color: #5c6370;">// Mục đích chính là để làm cơ sở so sánh hiệu năng với phiên bản nhân ma trận đa luồng.</span>

<span style="color: #5c6370;">// Bao gồm tệp header tự định nghĩa để sử dụng các hàm đọc/ghi ma trận và struct Matrix.</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">"matrix_utils.h"</span>
<span style="color: #5c6370;">// Bao gồm thư viện chrono để đo lường thời gian thực thi một cách chính xác.</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;chrono&gt;</span>

<span style="color: #5c6370;">// Hàm thực hiện nhân hai ma trận A và B một cách tuần tự.</span>
<span style="color: #5c6370;">// const Matrix& A, const Matrix& B: Nhận vào hai ma trận hằng dưới dạng tham chiếu</span>
<span style="color: #5c6370;">// để tránh sao chép dữ liệu không cần thiết, giúp tối ưu hiệu suất.</span>
Matrix <span style="color: #61afef;">multiply_sequentially</span>(<span style="color: #c678dd;">const</span> Matrix&amp; A, <span style="color: #c678dd;">const</span> Matrix&amp; B) {
    <span style="color: #5c6370;">// Tạo ma trận kết quả C.</span>
    Matrix C;
    <span style="color: #5c6370;">// Kích thước của ma trận C sẽ là số hàng của A và số cột của B.</span>
    C.rows = A.rows;
    C.cols = B.cols;
    <span style="color: #5c6370;">// Cấp phát bộ nhớ cho ma trận C và khởi tạo tất cả các phần tử bằng 0.</span>
    C.data.assign(C.rows, std::vector&lt;<span style="color: #d19a66;">int</span>&gt;(C.cols, <span style="color: #d19a66;">0</span>));

    <span style="color: #5c6370;">// Thuật toán nhân ma trận tiêu chuẩn sử dụng ba vòng lặp lồng nhau.</span>
    <span style="color: #5c6370;">// Vòng lặp ngoài cùng duyệt qua từng hàng của ma trận A (và ma trận C).</span>
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = <span style="color: #d19a66;">0</span>; i &lt; A.rows; ++i) {
        <span style="color: #5c6370;">// Vòng lặp thứ hai duyệt qua từng cột của ma trận B (và ma trận C).</span>
        <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> j = <span style="color: #d19a66;">0</span>; j &lt; B.cols; ++j) {
            <span style="color: #5c6370;">// Biến tạm để tính tổng cho phần tử C[i][j].</span>
            <span style="color: #d19a66;">int</span> sum = <span style="color: #d19a66;">0</span>;
            <span style="color: #5c6370;">// Vòng lặp trong cùng duyệt qua từng cột của A và hàng của B.</span>
            <span style="color: #5c6370;">// Đây là bước tính tích vô hướng (dot product) của hàng i của A và cột j của B.</span>
            <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> k = <span style="color: #d19a66;">0</span>; k &lt; A.cols; ++k) {
                sum += A.data[i][k] * B.data[k][j];
            }
            <span style="color: #5c6370;">// Gán giá trị tổng vừa tính được cho phần tử C[i][j].</span>
            C.data[i][j] = sum;
        }
    }
    <span style="color: #5c6370;">// Trả về ma trận kết quả C.</span>
    <span style="color: #c678dd;">return</span> C;
}

<span style="color: #5c6370;">// Hàm main - điểm bắt đầu của chương trình.</span>
<span style="color: #d19a66;">int</span> <span style="color: #61afef;">main</span>() {
    <span style="color: #5c6370;">// Sử dụng khối try-catch để xử lý các lỗi có thể xảy ra một cách an toàn.</span>
    <span style="color: #5c6370;">// Ví dụ: không tìm thấy file, file có định dạng sai, kích thước ma trận không hợp lệ.</span>
    <span style="color: #c678dd;">try</span> {
        <span style="color: #5c6370;">// Đọc ma trận A và B từ các tệp văn bản.</span>
        Matrix A = read_matrix_from_file(<span style="color: #98c379;">"A.txt"</span>);
        Matrix B = read_matrix_from_file(<span style="color: #98c379;">"B.txt"</span>);

        <span style="color: #5c6370;">// Điều kiện tiên quyết để nhân ma trận: số cột của A phải bằng số hàng của B.</span>
        <span style="color: #c678dd;">if</span> (A.cols != B.rows) {
            <span style="color: #5c6370;">// Nếu không thỏa mãn, ném ra một ngoại lệ với thông báo lỗi rõ ràng.</span>
            <span style="color: #c678dd;">throw</span> std::invalid_argument(<span style="color: #98c379;">"Error: Incompatible matrix dimensions for multiplication."</span>);
        }

        <span style="color: #5c6370;">// Bắt đầu đo thời gian thực thi.</span>
        <span style="color: #5c6370;">// high_resolution_clock cung cấp đồng hồ có độ chính xác cao nhất có thể trên hệ thống.</span>
        <span style="color: #d19a66;">auto</span> start_time = std::chrono::high_resolution_clock::now();
        <span style="color: #5c6370;">// Gọi hàm nhân ma trận tuần tự.</span>
        Matrix C = multiply_sequentially(A, B);
        <span style="color: #5c6370;">// Dừng đo thời gian.</span>
        <span style="color: #d19a66;">auto</span> end_time = std::chrono::high_resolution_clock::now();

        <span style="color: #5c6370;">// Tính toán khoảng thời gian đã trôi qua và chuyển đổi sang đơn vị mili giây.</span>
        <span style="color: #d19a66;">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_time - start_time);
        <span style="color: #5c6370;">// In thời gian thực thi ra màn hình.</span>
        std::cout &lt;&lt; <span style="color: #98c379;">"Time taken for sequential multiplication: "</span> &lt;&lt; duration.count() &lt;&lt; <span style="color: #98c379;">" milliseconds\n"</span>;

        <span style="color: #5c6370;">// Ghi ma trận kết quả C ra một tệp mới.</span>
        write_matrix_to_file(C, <span style="color: #98c379;">"C_sequential.txt"</span>);
        std::cout &lt;&lt; <span style="color: #98c379;">"Result saved to C_sequential.txt\n"</span>;

    <span style="color: #5c6370;">// Bắt (catch) bất kỳ ngoại lệ nào thuộc lớp std::exception hoặc lớp con của nó.</span>
    } <span style="color: #c678dd;">catch</span> (<span style="color: #c678dd;">const</span> std::exception&amp; e) {
        <span style="color: #5c6370;">// In thông báo lỗi ra luồng lỗi chuẩn (standard error).</span>
        std::cerr &lt;&lt; <span style="color: #98c379;">"An error occurred: "</span> &lt;&lt; e.what() &lt;&lt; std::endl;
        <span style="color: #5c6370;">// Trả về 1 để báo hiệu chương trình kết thúc với lỗi.</span>
        <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">1</span>;
    }
    <span style="color: #5c6370;">// Trả về 0 để báo hiệu chương trình kết thúc thành công.</span>
    <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">0</span>;
}`
        },
        'standard-mult': {
            explained: `<span style="color: #5c6370;">// multithread_standard.cpp</span>
<span style="color: #5c6370;">// Mô tả: Chương trình này thực hiện nhân ma trận song song sử dụng đa luồng.</span>
<span style="color: #5c6370;">// Cách tiếp cận là chia các hàng của ma trận kết quả cho các luồng khác nhau để tính toán.</span>
<span style="color: #5c6370;">// Đây là phương pháp cơ bản, giúp tăng tốc độ so với bản tuần tự nhưng có thể tối ưu hơn nữa.</span>

<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">"matrix_utils.h"</span> <span style="color: #5c6370;">// Sử dụng các hàm và struct đã định nghĩa để đọc/ghi ma trận.</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;chrono&gt;</span>         <span style="color: #5c6370;">// Thư viện để đo lường thời gian thực thi.</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;thread&gt;</span>         <span style="color: #5c6370;">// Cung cấp lớp std::thread để tạo và quản lý luồng.</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;functional&gt;</span>     <span style="color: #5c6370;">// Cần thiết để sử dụng std::ref và std::cref, giúp truyền tham chiếu tới luồng.</span>

<span style="color: #5c6370;">// Hàm công việc (worker function) được thực thi bởi mỗi luồng.</span>
<span style="color: #5c6370;">// Mỗi luồng sẽ chịu trách nhiệm tính toán một khoảng các hàng (từ start_row đến end_row).</span>
<span style="color: #5c6370;">// const Matrix& A, const Matrix& B: Nhận ma trận A, B dưới dạng tham chiếu hằng để đọc.</span>
<span style="color: #5c6370;">// Matrix& C: Nhận ma trận kết quả C dưới dạng tham chiếu KHÔNG HẰNG để có thể ghi kết quả vào.</span>
<span style="color: #c678dd;">void</span> <span style="color: #61afef;">standard_worker_task</span>(<span style="color: #c678dd;">const</span> Matrix&amp; A, <span style="color: #c678dd;">const</span> Matrix&amp; B, Matrix&amp; C, <span style="color: #d19a66;">int</span> start_row, <span style="color: #d19a66;">int</span> end_row) {
    <span style="color: #5c6370;">// Luồng này chỉ lặp qua các hàng được giao cho nó.</span>
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = start_row; i &lt; end_row; ++i) {
        <span style="color: #5c6370;">// Vòng lặp tính toán cho từng phần tử trên hàng i vẫn giữ nguyên như bản tuần tự.</span>
        <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> j = <span style="color: #d19a66;">0</span>; j &lt; B.cols; ++j) {
            <span style="color: #5c6370;">// Vòng lặp k thực hiện phép tích vô hướng (dot product).</span>
            <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> k = <span style="color: #d19a66;">0</span>; k &lt; A.cols; ++k) {
                <span style="color: #5c6370;">// Ghi kết quả trực tiếp vào ma trận C dùng chung.</span>
                <span style="color: #5c6370;">// Vì mỗi luồng ghi vào các hàng khác nhau (i khác nhau) nên không có xung đột dữ liệu.</span>
                C.data[i][j] += A.data[i][k] * B.data[k][j];
            }
        }
    }
}

<span style="color: #5c6370;">// Hàm điều phối chính, có nhiệm vụ chia việc và quản lý các luồng.</span>
Matrix <span style="color: #61afef;">multiply_multithreaded</span>(<span style="color: #c678dd;">const</span> Matrix&amp; A, <span style="color: #c678dd;">const</span> Matrix&amp; B) {
    <span style="color: #5c6370;">// Lấy số luồng phần cứng tối ưu mà hệ thống hỗ trợ.</span>
    <span style="color: #5c6370;">// Thường là số lõi (cores) hoặc số luồng siêu phân luồng (hyper-threads) của CPU.</span>
    <span style="color: #d19a66;">unsigned int</span> num_threads = std::thread::hardware_concurrency();
    
    <span style="color: #5c6370;">// Khởi tạo ma trận kết quả C với kích thước phù hợp và các giá trị ban đầu bằng 0.</span>
    Matrix C;
	C.rows = A.rows;
	C.cols = B.cols;
	C.data.assign(C.rows, std::vector&lt;<span style="color: #d19a66;">int</span>&gt;(C.cols, <span style="color: #d19a66;">0</span>));
    
    <span style="color: #5c6370;">// Vector để lưu trữ các đối tượng luồng, giúp quản lý chúng dễ dàng hơn.</span>
    std::vector&lt;std::thread&gt; threads;
    
    <span style="color: #5c6370;">// Tính toán số hàng cơ bản mà mỗi luồng sẽ xử lý.</span>
    <span style="color: #d19a66;">int</span> rows_per_thread = A.rows / num_threads;

    <span style="color: #5c6370;">// Vòng lặp để tạo và khởi chạy các luồng.</span>
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">unsigned int</span> i = <span style="color: #d19a66;">0</span>; i &lt; num_threads; ++i) {
        <span style="color: #5c6370;">// Tính toán chỉ số hàng bắt đầu và kết thúc cho luồng hiện tại.</span>
        <span style="color: #d19a66;">int</span> start = i * rows_per_thread;
        <span style="color: #5c6370;">// Xử lý đặc biệt cho luồng cuối cùng: nó sẽ nhận tất cả các hàng còn lại</span>
        <span style="color: #5c6370;">// để đảm bảo không hàng nào bị bỏ sót do phép chia số nguyên.</span>
        <span style="color: #d19a66;">int</span> end = (i == num_threads - <span style="color: #d19a66;">1</span>) ? A.rows : start + rows_per_thread;
        
        <span style="color: #5c6370;">// Tạo một luồng mới và thêm nó vào vector.</span>
        <span style="color: #5c6370;">// Luồng này sẽ chạy hàm standard_worker_task với các tham số được cung cấp.</span>
        <span style="color: #5c6370;">// std::cref(A), std::cref(B): Truyền A và B dưới dạng tham chiếu hằng (const reference).</span>
        <span style="color: #5c6370;">// std::ref(C): Truyền C dưới dạng tham chiếu không hằng (non-const reference).</span>
        <span style="color: #5c6370;">// start, end: Truyền các chỉ số hàng theo giá trị.</span>
        threads.emplace_back(standard_worker_task, std::cref(A), std::cref(B), std::ref(C), start, end);
    }

    <span style="color: #5c6370;">// Đợi tất cả các luồng hoàn thành công việc của chúng.</span>
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">auto</span>&amp; th : threads) {
        <span style="color: #5c6370;">// Lệnh join() sẽ chặn luồng chính cho đến khi luồng 'th' kết thúc.</span>
        th.join();
    }
    <span style="color: #5c6370;">// Sau khi tất cả các luồng đã join, ma trận C đã được tính toán đầy đủ.</span>
    <span style="color: #c678dd;">return</span> C;
}

<span style="color: #5c6370;">// Hàm main không có gì thay đổi nhiều so với bản tuần tự.</span>
<span style="color: #d19a66;">int</span> <span style="color: #61afef;">main</span>() {
    <span style="color: #c678dd;">try</span> {
        Matrix A = read_matrix_from_file(<span style="color: #98c379;">"A.txt"</span>);
        Matrix B = read_matrix_from_file(<span style="color: #98c379;">"B.txt"</span>);

        <span style="color: #c678dd;">if</span> (A.cols != B.rows) {
            <span style="color: #c678dd;">throw</span> std::invalid_argument(<span style="color: #98c379;">"Error: Incompatible matrix dimensions."</span>);
        }

        <span style="color: #5c6370;">// Đo thời gian của hàm nhân ma trận phiên bản đa luồng.</span>
        <span style="color: #d19a66;">auto</span> start_time = std::chrono::high_resolution_clock::now();
        Matrix C = multiply_multithreaded(A, B);
        <span style="color: #d19a66;">auto</span> end_time = std::chrono::high_resolution_clock::now();

        <span style="color: #d19a66;">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_time - start_time);
        std::cout &lt;&lt; <span style="color: #98c379;">"Time taken for standard multi-threading: "</span> &lt;&lt; duration.count() &lt;&lt; <span style="color: #98c379;">" milliseconds\n"</span>;

        write_matrix_to_file(C, <span style="color: #98c379;">"C_multithread_standard.txt"</span>);
        std::cout &lt;&lt; <span style="color: #98c379;">"Result saved to C_multithread_standard.txt\n"</span>;

    } <span style="color: #c678dd;">catch</span> (<span style="color: #c678dd;">const</span> std::exception&amp; e) {
        std::cerr &lt;&lt; <span style="color: #98c379;">"An error occurred: "</span> &lt;&lt; e.what() &lt;&lt; std::endl;
        <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">1</span>;
    }
    <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">0</span>;
}`
        },
        'optimized-mult': {
            explained: `<span style="color: #5c6370;">// multithread_optimized.cpp</span>
<span style="color: #5c6370;">// Mô tả: Phiên bản nhân ma trận đa luồng được tối ưu hóa.</span>
<span style="color: #5c6370;">// Tối ưu hóa chính là sử dụng một biến cục bộ để tính tổng cho mỗi phần tử,</span>
<span style="color: #5c6370;">// sau đó mới ghi kết quả ra bộ nhớ dùng chung. Việc này giảm đáng kể số lần</span>
<span style="color: #5c6370;">// truy cập và ghi vào bộ nhớ chung, giúp cải thiện hiệu năng và tránh các</span>
<span style="color: #5c6370;">// vấn đề tiềm ẩn như "False Sharing".</span>

<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">"matrix_utils.h"</span> <span style="color: #5c6370;">// Sử dụng các hàm và struct đã định nghĩa.</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;chrono&gt;</span>         <span style="color: #5c6370;">// Thư viện để đo lường thời gian.</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;thread&gt;</span>         <span style="color: #5c6370;">// Thư viện để làm việc với luồng.</span>
<span style="color: #c678dd;">#include</span> <span style="color: #98c379;">&lt;functional&gt;</span>     <span style="color: #5c6370;">// Cần cho std::ref và std::cref.</span>

<span style="color: #5c6370;">// Hàm công việc cho mỗi luồng (phiên bản đã được tối ưu hóa).</span>
<span style="color: #5c6370;">// Cấu trúc hàm vẫn tương tự, nhưng logic bên trong vòng lặp cuối cùng đã thay đổi.</span>
<span style="color: #c678dd;">void</span> <span style="color: #61afef;">optimized_worker_task</span>(<span style="color: #c678dd;">const</span> Matrix& A, <span style="color: #c678dd;">const</span> Matrix& B, Matrix& C, <span style="color: #d19a66;">int</span> start_row, <span style="color: #d19a66;">int</span> end_row) {
    <span style="color: #5c6370;">// Duyệt qua các hàng được giao cho luồng này.</span>
    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> i = start_row; i &lt; end_row; ++i) {
        <span style="color: #5c6370;">// Duyệt qua các cột của ma trận kết quả.</span>
        <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> j = <span style="color: #d19a66;">0</span>; j &lt; B.cols; ++j) {
            <span style="color: #5c6370;">// *** ĐIỂM TỐI ƯU HÓA QUAN TRỌNG NHẤT ***</span>
            <span style="color: #5c6370;">// Tạo một biến cục bộ sum cho mỗi luồng để tích lũy kết quả.</span>
            <span style="color: #5c6370;">// Biến này thường được lưu trong thanh ghi (register) của CPU, tốc độ truy cập cực nhanh.</span>
            <span style="color: #d19a66;">int</span> sum = <span style="color: #d19a66;">0</span>;
            
            <span style="color: #5c6370;">// Vòng lặp trong cùng để thực hiện phép tích vô hướng.</span>
            <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">int</span> k = <span style="color: #d19a66;">0</span>; k &lt; A.cols; ++k) {
                <span style="color: #5c6370;">// Mọi phép tính cộng dồn đều được thực hiện trên biến cục bộ sum.</span>
                <span style="color: #5c6370;">// Hoàn toàn không có thao tác ghi vào ma trận C (bộ nhớ chung) trong vòng lặp này.</span>
                sum += A.data[i][k] * B.data[k][j];
            }
            
            <span style="color: #5c6370;">// Sau khi vòng lặp k kết thúc, chúng ta mới thực hiện MỘT LẦN GHI DUY NHẤT</span>
            <span style="color: #5c6370;">// vào bộ nhớ chung cho phần tử C.data[i][j].</span>
            C.data[i][j] = sum;
        }
    }
}

<span style="color: #5c6370;">// Hàm điều phối chính (hoàn toàn tương tự bản standard).</span>
<span style="color: #5c6370;">// Sự khác biệt duy nhất là nó gọi optimized_worker_task thay vì standard_worker_task.</span>
Matrix <span style="color: #61afef;">multiply_multithreaded_optimized</span>(<span style="color: #c678dd;">const</span> Matrix& A, <span style="color: #c678dd;">const</span> Matrix& B) {
    <span style="color: #d19a66;">unsigned int</span> num_threads = std::thread::hardware_concurrency();
    Matrix C;
	C.rows = A.rows;
	C.cols = B.cols;
	C.data.assign(C.rows, std::vector&lt;<span style="color: #d19a66;">int</span>&gt;(C.cols, <span style="color: #d19a66;">0</span>));
    std::vector&lt;std::thread&gt; threads;
    
    <span style="color: #d19a66;">int</span> rows_per_thread = A.rows / num_threads;

    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">unsigned int</span> i = <span style="color: #d19a66;">0</span>; i &lt; num_threads; ++i) {
        <span style="color: #d19a66;">int</span> start = i * rows_per_thread;
        <span style="color: #d19a66;">int</span> end = (i == num_threads - <span style="color: #d19a66;">1</span>) ? A.rows : start + rows_per_thread;
        <span style="color: #5c6370;">// Gọi đến hàm worker đã được tối ưu hóa.</span>
        threads.emplace_back(optimized_worker_task, std::cref(A), std::cref(B), std::ref(C), start, end);
    }

    <span style="color: #c678dd;">for</span> (<span style="color: #d19a66;">auto</span>&amp; th : threads) {
        th.join();
    }
    <span style="color: #c678dd;">return</span> C;
}

<span style="color: #5c6370;">// Hàm main không có thay đổi về logic, chỉ gọi hàm nhân ma trận phiên bản tối ưu.</span>
<span style="color: #d19a66;">int</span> <span style="color: #61afef;">main</span>() {
    <span style="color: #c678dd;">try</span> {
        Matrix A = read_matrix_from_file(<span style="color: #98c379;">"A.txt"</span>);
        Matrix B = read_matrix_from_file(<span style="color: #98c379;">"B.txt"</span>);

        <span style="color: #c678dd;">if</span> (A.cols != B.rows) {
            <span style="color: #c678dd;">throw</span> std::invalid_argument(<span style="color: #98c379;">"Error: Incompatible matrix dimensions."</span>);
        }

        <span style="color: #d19a66;">auto</span> start_time = std::chrono::high_resolution_clock::now();
        <span style="color: #5c6370;">// Gọi hàm nhân ma trận phiên bản tối ưu để đo thời gian.</span>
        Matrix C = multiply_multithreaded_optimized(A, B);
        <span style="color: #d19a66;">auto</span> end_time = std::chrono::high_resolution_clock::now();

        <span style="color: #d19a66;">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_time - start_time);
        std::cout &lt;&lt; <span style="color: #98c379;">"Time taken for OPTIMIZED multi-threading: "</span> &lt;&lt; duration.count() &lt;&lt; <span style="color: #98c379;">" milliseconds\n"</span>;

        write_matrix_to_file(C, <span style="color: #98c379;">"C_multithread_optimized.txt"</span>);
        std::cout &lt;&lt; <span style="color: #98c379;">"Result saved to C_multithread_optimized.txt\n"</span>;

    } <span style="color: #c678dd;">catch</span> (<span style="color: #c678dd;">const</span> std::exception& e) {
        std::cerr &lt;&lt; <span style="color: #98c379;">"An error occurred: "</span> &lt;&lt; e.what() &lt;&lt; std::endl;
        <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">1</span>;
    }
    <span style="color: #c678dd;">return</span> <span style="color: #d19a66;">0</span>;
}`
        }
};

    // --- Lưu nội dung code gốc vào object `exampleContents` ---
    for (const id in exampleContents) {
        const block = document.querySelector(`.code-block[data-example-id="${id}"]`);
        if (block) {
            exampleContents[id].original = block.querySelector('pre code').innerHTML;
        }
    }

    // Lặp qua tất cả các khối code có data-example-id để thêm thanh công cụ
    document.querySelectorAll('.code-block[data-example-id]').forEach(block => {
        const exampleId = block.dataset.exampleId;
        const container = block.closest('.code-container');
        if (!container || !exampleContents[exampleId]) return;

        const toolbar = document.createElement('div');
        toolbar.className = 'code-toolbar';

        const explainButton = document.createElement('button');
        explainButton.className = 'toolbar-button';
        explainButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.064.293.006.399.287.47l.45.082.082.38-2.29.287-.082-.38.45-.083a.49.49 0 0 1 .352-.176c.07-.294-.055-.469-.288-.469l-.738-3.468c-.064-.293-.006-.399-.287-.47l-.45-.082-.082-.38 2.29-.287.082.38-.45.083C6.931 6.648 6.865 7.02 7.03 7.29l.738 3.468c.064.293.006.399.287.47l.45.082.082.38-2.29.287-.082-.38.45-.083a.49.49 0 0 1 .352-.176c.07-.294-.055-.469-.288-.469l-.738-3.468c-.064-.293-.006-.399-.287-.47l-.45-.082-.082-.38 2.29-.287.082.38z"/></svg>
            <span>Giải thích</span>`;
        
        const copyButton = document.createElement('button');
        copyButton.className = 'toolbar-button';
        copyButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16"><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/><path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/></svg>
            <span>Sao chép</span>`;

        toolbar.appendChild(explainButton);
        toolbar.appendChild(copyButton);
        block.prepend(toolbar);

        explainButton.addEventListener('click', () => {
            const explanationPanel = container.querySelector('.explanation-panel');
            const codeElement = block.querySelector('pre code');
            const isHidden = explanationPanel.classList.toggle('hidden');
            
            explainButton.querySelector('span').textContent = isHidden ? 'Giải thích' : 'Ẩn';

            if (isHidden) { 
                 codeElement.innerHTML = exampleContents[exampleId].original;
            } else { 
                 codeElement.innerHTML = exampleContents[exampleId].explained;
            }
        });

        copyButton.addEventListener('click', () => {
            const code = block.querySelector('pre code');
            if (code) {
                navigator.clipboard.writeText(code.innerText).then(() => {
                    const span = copyButton.querySelector('span');
                    const originalText = span.textContent;
                    span.textContent = 'Đã chép!';
                    setTimeout(() => { span.textContent = originalText; }, 2000);
                });
            }
        });
    });
});
</script>
</body>
</html>